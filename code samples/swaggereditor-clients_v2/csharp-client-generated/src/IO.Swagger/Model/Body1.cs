/* 
 * Swagger for Utility Network
 *
 * Open API Specification (OAS/Swagger)  * **trace**, **updateIsConnected** from the [ArcGIS Utility Network](https://developers.arcgis.com/rest/services-reference/utility-network-service.htm) * **generateToken** from the [ArcGIS REST API](https://developers.arcgis.com/rest/)  Tested on ArcGIS  Enterprise 10.8.1 using OpenAPI Specification (OAC) written in [SwaggerEditor](https://github.com/swagger-api/swagger-editor)   and [SwaggerHub](https://app.swaggerhub.com/) for C# and Typescript-Angular code generation.  
 *
 * OpenAPI spec version: 3.0
 * Contact: kim.sundeen@sspinnovations.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Body1
    /// </summary>
    [DataContract]
        public partial class Body1 :  IEquatable<Body1>, IValidatableObject
    {
        /// <summary>
        /// The trace type.
        /// </summary>
        /// <value>The trace type.</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum TraceTypeEnum
        {
            /// <summary>
            /// Enum Upstream for value: upstream
            /// </summary>
            [EnumMember(Value = "upstream")]
            Upstream = 1,
            /// <summary>
            /// Enum Downstream for value: downstream
            /// </summary>
            [EnumMember(Value = "downstream")]
            Downstream = 2,
            /// <summary>
            /// Enum Connected for value: connected
            /// </summary>
            [EnumMember(Value = "connected")]
            Connected = 3,
            /// <summary>
            /// Enum Subnetwork for value: subnetwork
            /// </summary>
            [EnumMember(Value = "subnetwork")]
            Subnetwork = 4,
            /// <summary>
            /// Enum Unknown for value: unknown
            /// </summary>
            [EnumMember(Value = "unknown")]
            Unknown = 5,
            /// <summary>
            /// Enum Loops for value: loops
            /// </summary>
            [EnumMember(Value = "loops")]
            Loops = 6,
            /// <summary>
            /// Enum Shortestpath for value: shortestpath
            /// </summary>
            [EnumMember(Value = "shortestpath")]
            Shortestpath = 7,
            /// <summary>
            /// Enum Subnetworkcontroller for value: subnetworkcontroller
            /// </summary>
            [EnumMember(Value = "subnetworkcontroller")]
            Subnetworkcontroller = 8        }
        /// <summary>
        /// The trace type.
        /// </summary>
        /// <value>The trace type.</value>
        [DataMember(Name="traceType", EmitDefaultValue=false)]
        public TraceTypeEnum TraceType { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Body1" /> class.
        /// </summary>
        /// <param name="f">Optional parameter representing the output format of the response (default is JSON). (required) (default to &quot;json&quot;).</param>
        /// <param name="gdbVersion">The name of the geodatabase version. (default to &quot;sde.DEFAULT&quot;).</param>
        /// <param name="sessionId">Optional parameter representing the token (guid) used to lock the version. If the calling client has previously started a service session (editing) and holds an exclusive lock on the specified version, the request will fail if the sessionId is not provided. If the specified version is currently locked by any other session, the request will fail if the sessionId is not provided or does not match the sessionId which holds the exclusive lock. (default to &quot;&quot;).</param>
        /// <param name="moment">Optional parameter representing the session moment (the default is the version current moment). This should only be specified by the client when they do not want to use the current moment..</param>
        /// <param name="traceType">The trace type. (required).</param>
        /// <param name="traceLocations">***Curently a workaround until figure out how to gen**The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types. (required).</param>
        /// <param name="traceConfiguration">The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types. (required).</param>
        /// <param name="resultTypes">Optional parameter representing the types of results to return. (required).</param>
        public Body1(string f = "json", string gdbVersion = "sde.DEFAULT", string sessionId = "", string moment = default(string), TraceTypeEnum traceType = default(TraceTypeEnum), List traceLocations = default(List), Object traceConfiguration = default(Object), List resultTypes = default(List))
        {
            // to ensure "f" is required (not null)
            if (f == null)
            {
                throw new InvalidDataException("f is a required property for Body1 and cannot be null");
            }
            else
            {
                this.F = f;
            }
            // to ensure "traceType" is required (not null)
            if (traceType == null)
            {
                throw new InvalidDataException("traceType is a required property for Body1 and cannot be null");
            }
            else
            {
                this.TraceType = traceType;
            }
            // to ensure "traceLocations" is required (not null)
            if (traceLocations == null)
            {
                throw new InvalidDataException("traceLocations is a required property for Body1 and cannot be null");
            }
            else
            {
                this.TraceLocations = traceLocations;
            }
            // to ensure "traceConfiguration" is required (not null)
            if (traceConfiguration == null)
            {
                throw new InvalidDataException("traceConfiguration is a required property for Body1 and cannot be null");
            }
            else
            {
                this.TraceConfiguration = traceConfiguration;
            }
            // to ensure "resultTypes" is required (not null)
            if (resultTypes == null)
            {
                throw new InvalidDataException("resultTypes is a required property for Body1 and cannot be null");
            }
            else
            {
                this.ResultTypes = resultTypes;
            }
            // use default value if no "gdbVersion" provided
            if (gdbVersion == null)
            {
                this.GdbVersion = "sde.DEFAULT";
            }
            else
            {
                this.GdbVersion = gdbVersion;
            }
            // use default value if no "sessionId" provided
            if (sessionId == null)
            {
                this.SessionId = "";
            }
            else
            {
                this.SessionId = sessionId;
            }
            this.Moment = moment;
        }
        
        /// <summary>
        /// Optional parameter representing the output format of the response (default is JSON).
        /// </summary>
        /// <value>Optional parameter representing the output format of the response (default is JSON).</value>
        [DataMember(Name="f", EmitDefaultValue=false)]
        public string F { get; set; }

        /// <summary>
        /// The name of the geodatabase version.
        /// </summary>
        /// <value>The name of the geodatabase version.</value>
        [DataMember(Name="gdbVersion", EmitDefaultValue=false)]
        public string GdbVersion { get; set; }

        /// <summary>
        /// Optional parameter representing the token (guid) used to lock the version. If the calling client has previously started a service session (editing) and holds an exclusive lock on the specified version, the request will fail if the sessionId is not provided. If the specified version is currently locked by any other session, the request will fail if the sessionId is not provided or does not match the sessionId which holds the exclusive lock.
        /// </summary>
        /// <value>Optional parameter representing the token (guid) used to lock the version. If the calling client has previously started a service session (editing) and holds an exclusive lock on the specified version, the request will fail if the sessionId is not provided. If the specified version is currently locked by any other session, the request will fail if the sessionId is not provided or does not match the sessionId which holds the exclusive lock.</value>
        [DataMember(Name="sessionId", EmitDefaultValue=false)]
        public string SessionId { get; set; }

        /// <summary>
        /// Optional parameter representing the session moment (the default is the version current moment). This should only be specified by the client when they do not want to use the current moment.
        /// </summary>
        /// <value>Optional parameter representing the session moment (the default is the version current moment). This should only be specified by the client when they do not want to use the current moment.</value>
        [DataMember(Name="moment", EmitDefaultValue=false)]
        public string Moment { get; set; }


        /// <summary>
        /// ***Curently a workaround until figure out how to gen**The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.
        /// </summary>
        /// <value>***Curently a workaround until figure out how to gen**The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.</value>
        [DataMember(Name="traceLocations", EmitDefaultValue=false)]
        public List TraceLocations { get; set; }

        /// <summary>
        /// The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.
        /// </summary>
        /// <value>The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.</value>
        [DataMember(Name="traceConfiguration", EmitDefaultValue=false)]
        public Object TraceConfiguration { get; set; }

        /// <summary>
        /// Optional parameter representing the types of results to return.
        /// </summary>
        /// <value>Optional parameter representing the types of results to return.</value>
        [DataMember(Name="resultTypes", EmitDefaultValue=false)]
        public List ResultTypes { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Body1 {\n");
            sb.Append("  F: ").Append(F).Append("\n");
            sb.Append("  GdbVersion: ").Append(GdbVersion).Append("\n");
            sb.Append("  SessionId: ").Append(SessionId).Append("\n");
            sb.Append("  Moment: ").Append(Moment).Append("\n");
            sb.Append("  TraceType: ").Append(TraceType).Append("\n");
            sb.Append("  TraceLocations: ").Append(TraceLocations).Append("\n");
            sb.Append("  TraceConfiguration: ").Append(TraceConfiguration).Append("\n");
            sb.Append("  ResultTypes: ").Append(ResultTypes).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Body1);
        }

        /// <summary>
        /// Returns true if Body1 instances are equal
        /// </summary>
        /// <param name="input">Instance of Body1 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Body1 input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.F == input.F ||
                    (this.F != null &&
                    this.F.Equals(input.F))
                ) && 
                (
                    this.GdbVersion == input.GdbVersion ||
                    (this.GdbVersion != null &&
                    this.GdbVersion.Equals(input.GdbVersion))
                ) && 
                (
                    this.SessionId == input.SessionId ||
                    (this.SessionId != null &&
                    this.SessionId.Equals(input.SessionId))
                ) && 
                (
                    this.Moment == input.Moment ||
                    (this.Moment != null &&
                    this.Moment.Equals(input.Moment))
                ) && 
                (
                    this.TraceType == input.TraceType ||
                    (this.TraceType != null &&
                    this.TraceType.Equals(input.TraceType))
                ) && 
                (
                    this.TraceLocations == input.TraceLocations ||
                    (this.TraceLocations != null &&
                    this.TraceLocations.Equals(input.TraceLocations))
                ) && 
                (
                    this.TraceConfiguration == input.TraceConfiguration ||
                    (this.TraceConfiguration != null &&
                    this.TraceConfiguration.Equals(input.TraceConfiguration))
                ) && 
                (
                    this.ResultTypes == input.ResultTypes ||
                    (this.ResultTypes != null &&
                    this.ResultTypes.Equals(input.ResultTypes))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.F != null)
                    hashCode = hashCode * 59 + this.F.GetHashCode();
                if (this.GdbVersion != null)
                    hashCode = hashCode * 59 + this.GdbVersion.GetHashCode();
                if (this.SessionId != null)
                    hashCode = hashCode * 59 + this.SessionId.GetHashCode();
                if (this.Moment != null)
                    hashCode = hashCode * 59 + this.Moment.GetHashCode();
                if (this.TraceType != null)
                    hashCode = hashCode * 59 + this.TraceType.GetHashCode();
                if (this.TraceLocations != null)
                    hashCode = hashCode * 59 + this.TraceLocations.GetHashCode();
                if (this.TraceConfiguration != null)
                    hashCode = hashCode * 59 + this.TraceConfiguration.GetHashCode();
                if (this.ResultTypes != null)
                    hashCode = hashCode * 59 + this.ResultTypes.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
