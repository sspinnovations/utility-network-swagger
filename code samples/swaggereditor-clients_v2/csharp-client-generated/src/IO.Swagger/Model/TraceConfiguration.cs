/* 
 * Swagger for Utility Network
 *
 * Open API Specification (OAS/Swagger)  * **trace**, **updateIsConnected** from the [ArcGIS Utility Network](https://developers.arcgis.com/rest/services-reference/utility-network-service.htm) * **generateToken** from the [ArcGIS REST API](https://developers.arcgis.com/rest/)  Tested on ArcGIS  Enterprise 10.8.1 using OpenAPI Specification (OAC) written in [SwaggerEditor](https://github.com/swagger-api/swagger-editor)   and [SwaggerHub](https://app.swaggerhub.com/) for C# and Typescript-Angular code generation.  
 *
 * OpenAPI spec version: 3.0
 * Contact: kim.sundeen@sspinnovations.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// TraceConfiguration
    /// </summary>
    [DataContract]
        public partial class TraceConfiguration :  IEquatable<TraceConfiguration>, IValidatableObject
    {
        /// <summary>
        /// Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).
        /// </summary>
        /// <value>Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum TraversabilityScopeEnum
        {
            /// <summary>
            /// Enum Junctions for value: junctions
            /// </summary>
            [EnumMember(Value = "junctions")]
            Junctions = 1,
            /// <summary>
            /// Enum Edges for value: edges
            /// </summary>
            [EnumMember(Value = "edges")]
            Edges = 2,
            /// <summary>
            /// Enum JunctionsAndEdges for value: junctionsAndEdges
            /// </summary>
            [EnumMember(Value = "junctionsAndEdges")]
            JunctionsAndEdges = 3        }
        /// <summary>
        /// Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).
        /// </summary>
        /// <value>Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).</value>
        [DataMember(Name="traversabilityScope", EmitDefaultValue=false)]
        public TraversabilityScopeEnum? TraversabilityScope { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TraceConfiguration" /> class.
        /// </summary>
        /// <param name="includeContainers">Optional parameter representing whether or not to include containers in the trace result (default is false). (default to false).</param>
        /// <param name="includeContent">Optional parameter representing whether or not to include content in the trace result (default is false). (default to false).</param>
        /// <param name="includeStructures">Optional parameter representing whether or not to include structures in the trace result (default is false). (default to false).</param>
        /// <param name="includeBarriers">Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true). (default to true).</param>
        /// <param name="validateConsistency">Optional parameter representing whether or not to validate the consistency of the trace results (default is false). (default to false).</param>
        /// <param name="includeIsolated">Optional property specifying whether to include isolated features for an isolation trace (the default is false). (default to false).</param>
        /// <param name="ignoreBarriersAtStartingPoints">Optional property specifying whether dynamic barriers in the trace configuration are ignored for starting points. This can be useful when performing an upstream protective device trace using the discovered protective devices (barriers) as starting points to find subsequent upstream protective devices (the default is false). (default to false).</param>
        /// <param name="includeUpToFirstSpatialContainer">Optional property representing whether to limit the containers returned in the trace result. This property depends on the includeContainers property and no-ops if includeContainers is false. If includeContainers is true and this property is true, containment associations up to, and including the first spatial container will be returned; otherwise all containment associations will be returned (the default is false). (default to false).</param>
        /// <param name="domainNetworkName">Specifies the name of the domain network where the trace is starting. This is required for subnetwork-based traces. (default to &quot;&quot;).</param>
        /// <param name="tierName">Optional parameter that specifies the name of the tier where the trace is starting. (default to &quot;&quot;).</param>
        /// <param name="targetTierName">Optional parameter representing the name of the tier where upstream or downstream trace ends. (default to &quot;&quot;).</param>
        /// <param name="subnetworkName">Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork . (default to &quot;&quot;).</param>
        /// <param name="diagramTemplateName">Optional parameter representing the name of the diagram template. (default to &quot;&quot;).</param>
        /// <param name="shortestPathNetworkAttributeName">Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path. (default to &quot;&quot;).</param>
        /// <param name="filterBitsetNetworkAttributeName">Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute. (default to &quot;&quot;).</param>
        /// <param name="traversabilityScope">Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges). (default to TraversabilityScopeEnum.JunctionsAndEdges).</param>
        /// <param name="filterScope">filterScope (default to &quot;junctionsAndEdges&quot;).</param>
        /// <param name="conditionBarriers">Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute. (required).</param>
        /// <param name="functionBarriers">optional parameter. (required).</param>
        /// <param name="categoryBarriers">The categories that serve as barriers (default is none) : optional parameter..</param>
        /// <param name="filterBarriers">A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter. (required).</param>
        /// <param name="filterFunctionBarriers">filterFunctionBarriers (required).</param>
        /// <param name="functions">Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions. (required).</param>
        /// <param name="nearestNeighbor">nearestNeighbor (required).</param>
        /// <param name="outputFilterCategories">Optional property. This is an array of objects representing categories associated with the output filter (the default is none)..</param>
        /// <param name="outputFilters">Optional property representing the output filter; an array of objects (default is null). (required).</param>
        /// <param name="outputConditions">Optional property specifying the type of features returned based on a network attribute or category. (required).</param>
        /// <param name="arcadeExpressionBarrier">arcadeExpressionBarrier (default to &quot;&quot;).</param>
        /// <param name="propagators">propagators (required).</param>
        public TraceConfiguration(bool? includeContainers = false, bool? includeContent = false, bool? includeStructures = false, bool? includeBarriers = true, bool? validateConsistency = false, bool? includeIsolated = false, bool? ignoreBarriersAtStartingPoints = false, bool? includeUpToFirstSpatialContainer = false, string domainNetworkName = "", string tierName = "", string targetTierName = "", string subnetworkName = "", string diagramTemplateName = "", string shortestPathNetworkAttributeName = "", string filterBitsetNetworkAttributeName = "", TraversabilityScopeEnum? traversabilityScope = TraversabilityScopeEnum.JunctionsAndEdges, string filterScope = "junctionsAndEdges", List<ConditionBarrier> conditionBarriers = default(List<ConditionBarrier>), List<FunctionBarrier> functionBarriers = default(List<FunctionBarrier>), List<string> categoryBarriers = default(List<string>), List<string> filterBarriers = default(List<string>), List<string> filterFunctionBarriers = default(List<string>), Object functions = default(Object), NearestNeighborParam nearestNeighbor = default(NearestNeighborParam), Object outputFilterCategories = default(Object), List<OutputFilter> outputFilters = default(List<OutputFilter>), List<TraceOutputCondition> outputConditions = default(List<TraceOutputCondition>), string arcadeExpressionBarrier = "", List<Propagator> propagators = default(List<Propagator>))
        {
            // to ensure "conditionBarriers" is required (not null)
            if (conditionBarriers == null)
            {
                throw new InvalidDataException("conditionBarriers is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.ConditionBarriers = conditionBarriers;
            }
            // to ensure "functionBarriers" is required (not null)
            if (functionBarriers == null)
            {
                throw new InvalidDataException("functionBarriers is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.FunctionBarriers = functionBarriers;
            }
            // to ensure "filterBarriers" is required (not null)
            if (filterBarriers == null)
            {
                throw new InvalidDataException("filterBarriers is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.FilterBarriers = filterBarriers;
            }
            // to ensure "filterFunctionBarriers" is required (not null)
            if (filterFunctionBarriers == null)
            {
                throw new InvalidDataException("filterFunctionBarriers is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.FilterFunctionBarriers = filterFunctionBarriers;
            }
            // to ensure "functions" is required (not null)
            if (functions == null)
            {
                throw new InvalidDataException("functions is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.Functions = functions;
            }
            // to ensure "nearestNeighbor" is required (not null)
            if (nearestNeighbor == null)
            {
                throw new InvalidDataException("nearestNeighbor is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.NearestNeighbor = nearestNeighbor;
            }
            // to ensure "outputFilters" is required (not null)
            if (outputFilters == null)
            {
                throw new InvalidDataException("outputFilters is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.OutputFilters = outputFilters;
            }
            // to ensure "outputConditions" is required (not null)
            if (outputConditions == null)
            {
                throw new InvalidDataException("outputConditions is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.OutputConditions = outputConditions;
            }
            // to ensure "propagators" is required (not null)
            if (propagators == null)
            {
                throw new InvalidDataException("propagators is a required property for TraceConfiguration and cannot be null");
            }
            else
            {
                this.Propagators = propagators;
            }
            // use default value if no "includeContainers" provided
            if (includeContainers == null)
            {
                this.IncludeContainers = false;
            }
            else
            {
                this.IncludeContainers = includeContainers;
            }
            // use default value if no "includeContent" provided
            if (includeContent == null)
            {
                this.IncludeContent = false;
            }
            else
            {
                this.IncludeContent = includeContent;
            }
            // use default value if no "includeStructures" provided
            if (includeStructures == null)
            {
                this.IncludeStructures = false;
            }
            else
            {
                this.IncludeStructures = includeStructures;
            }
            // use default value if no "includeBarriers" provided
            if (includeBarriers == null)
            {
                this.IncludeBarriers = true;
            }
            else
            {
                this.IncludeBarriers = includeBarriers;
            }
            // use default value if no "validateConsistency" provided
            if (validateConsistency == null)
            {
                this.ValidateConsistency = false;
            }
            else
            {
                this.ValidateConsistency = validateConsistency;
            }
            // use default value if no "includeIsolated" provided
            if (includeIsolated == null)
            {
                this.IncludeIsolated = false;
            }
            else
            {
                this.IncludeIsolated = includeIsolated;
            }
            // use default value if no "ignoreBarriersAtStartingPoints" provided
            if (ignoreBarriersAtStartingPoints == null)
            {
                this.IgnoreBarriersAtStartingPoints = false;
            }
            else
            {
                this.IgnoreBarriersAtStartingPoints = ignoreBarriersAtStartingPoints;
            }
            // use default value if no "includeUpToFirstSpatialContainer" provided
            if (includeUpToFirstSpatialContainer == null)
            {
                this.IncludeUpToFirstSpatialContainer = false;
            }
            else
            {
                this.IncludeUpToFirstSpatialContainer = includeUpToFirstSpatialContainer;
            }
            // use default value if no "domainNetworkName" provided
            if (domainNetworkName == null)
            {
                this.DomainNetworkName = "";
            }
            else
            {
                this.DomainNetworkName = domainNetworkName;
            }
            // use default value if no "tierName" provided
            if (tierName == null)
            {
                this.TierName = "";
            }
            else
            {
                this.TierName = tierName;
            }
            // use default value if no "targetTierName" provided
            if (targetTierName == null)
            {
                this.TargetTierName = "";
            }
            else
            {
                this.TargetTierName = targetTierName;
            }
            // use default value if no "subnetworkName" provided
            if (subnetworkName == null)
            {
                this.SubnetworkName = "";
            }
            else
            {
                this.SubnetworkName = subnetworkName;
            }
            // use default value if no "diagramTemplateName" provided
            if (diagramTemplateName == null)
            {
                this.DiagramTemplateName = "";
            }
            else
            {
                this.DiagramTemplateName = diagramTemplateName;
            }
            // use default value if no "shortestPathNetworkAttributeName" provided
            if (shortestPathNetworkAttributeName == null)
            {
                this.ShortestPathNetworkAttributeName = "";
            }
            else
            {
                this.ShortestPathNetworkAttributeName = shortestPathNetworkAttributeName;
            }
            // use default value if no "filterBitsetNetworkAttributeName" provided
            if (filterBitsetNetworkAttributeName == null)
            {
                this.FilterBitsetNetworkAttributeName = "";
            }
            else
            {
                this.FilterBitsetNetworkAttributeName = filterBitsetNetworkAttributeName;
            }
            // use default value if no "traversabilityScope" provided
            if (traversabilityScope == null)
            {
                this.TraversabilityScope = TraversabilityScopeEnum.JunctionsAndEdges;
            }
            else
            {
                this.TraversabilityScope = traversabilityScope;
            }
            // use default value if no "filterScope" provided
            if (filterScope == null)
            {
                this.FilterScope = "junctionsAndEdges";
            }
            else
            {
                this.FilterScope = filterScope;
            }
            this.CategoryBarriers = categoryBarriers;
            this.OutputFilterCategories = outputFilterCategories;
            // use default value if no "arcadeExpressionBarrier" provided
            if (arcadeExpressionBarrier == null)
            {
                this.ArcadeExpressionBarrier = "";
            }
            else
            {
                this.ArcadeExpressionBarrier = arcadeExpressionBarrier;
            }
        }
        
        /// <summary>
        /// Optional parameter representing whether or not to include containers in the trace result (default is false).
        /// </summary>
        /// <value>Optional parameter representing whether or not to include containers in the trace result (default is false).</value>
        [DataMember(Name="includeContainers", EmitDefaultValue=false)]
        public bool? IncludeContainers { get; set; }

        /// <summary>
        /// Optional parameter representing whether or not to include content in the trace result (default is false).
        /// </summary>
        /// <value>Optional parameter representing whether or not to include content in the trace result (default is false).</value>
        [DataMember(Name="includeContent", EmitDefaultValue=false)]
        public bool? IncludeContent { get; set; }

        /// <summary>
        /// Optional parameter representing whether or not to include structures in the trace result (default is false).
        /// </summary>
        /// <value>Optional parameter representing whether or not to include structures in the trace result (default is false).</value>
        [DataMember(Name="includeStructures", EmitDefaultValue=false)]
        public bool? IncludeStructures { get; set; }

        /// <summary>
        /// Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true).
        /// </summary>
        /// <value>Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true).</value>
        [DataMember(Name="includeBarriers", EmitDefaultValue=false)]
        public bool? IncludeBarriers { get; set; }

        /// <summary>
        /// Optional parameter representing whether or not to validate the consistency of the trace results (default is false).
        /// </summary>
        /// <value>Optional parameter representing whether or not to validate the consistency of the trace results (default is false).</value>
        [DataMember(Name="validateConsistency", EmitDefaultValue=false)]
        public bool? ValidateConsistency { get; set; }

        /// <summary>
        /// Optional property specifying whether to include isolated features for an isolation trace (the default is false).
        /// </summary>
        /// <value>Optional property specifying whether to include isolated features for an isolation trace (the default is false).</value>
        [DataMember(Name="includeIsolated", EmitDefaultValue=false)]
        public bool? IncludeIsolated { get; set; }

        /// <summary>
        /// Optional property specifying whether dynamic barriers in the trace configuration are ignored for starting points. This can be useful when performing an upstream protective device trace using the discovered protective devices (barriers) as starting points to find subsequent upstream protective devices (the default is false).
        /// </summary>
        /// <value>Optional property specifying whether dynamic barriers in the trace configuration are ignored for starting points. This can be useful when performing an upstream protective device trace using the discovered protective devices (barriers) as starting points to find subsequent upstream protective devices (the default is false).</value>
        [DataMember(Name="ignoreBarriersAtStartingPoints", EmitDefaultValue=false)]
        public bool? IgnoreBarriersAtStartingPoints { get; set; }

        /// <summary>
        /// Optional property representing whether to limit the containers returned in the trace result. This property depends on the includeContainers property and no-ops if includeContainers is false. If includeContainers is true and this property is true, containment associations up to, and including the first spatial container will be returned; otherwise all containment associations will be returned (the default is false).
        /// </summary>
        /// <value>Optional property representing whether to limit the containers returned in the trace result. This property depends on the includeContainers property and no-ops if includeContainers is false. If includeContainers is true and this property is true, containment associations up to, and including the first spatial container will be returned; otherwise all containment associations will be returned (the default is false).</value>
        [DataMember(Name="includeUpToFirstSpatialContainer", EmitDefaultValue=false)]
        public bool? IncludeUpToFirstSpatialContainer { get; set; }

        /// <summary>
        /// Specifies the name of the domain network where the trace is starting. This is required for subnetwork-based traces.
        /// </summary>
        /// <value>Specifies the name of the domain network where the trace is starting. This is required for subnetwork-based traces.</value>
        [DataMember(Name="domainNetworkName", EmitDefaultValue=false)]
        public string DomainNetworkName { get; set; }

        /// <summary>
        /// Optional parameter that specifies the name of the tier where the trace is starting.
        /// </summary>
        /// <value>Optional parameter that specifies the name of the tier where the trace is starting.</value>
        [DataMember(Name="tierName", EmitDefaultValue=false)]
        public string TierName { get; set; }

        /// <summary>
        /// Optional parameter representing the name of the tier where upstream or downstream trace ends.
        /// </summary>
        /// <value>Optional parameter representing the name of the tier where upstream or downstream trace ends.</value>
        [DataMember(Name="targetTierName", EmitDefaultValue=false)]
        public string TargetTierName { get; set; }

        /// <summary>
        /// Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork .
        /// </summary>
        /// <value>Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork .</value>
        [DataMember(Name="subnetworkName", EmitDefaultValue=false)]
        public string SubnetworkName { get; set; }

        /// <summary>
        /// Optional parameter representing the name of the diagram template.
        /// </summary>
        /// <value>Optional parameter representing the name of the diagram template.</value>
        [DataMember(Name="diagramTemplateName", EmitDefaultValue=false)]
        public string DiagramTemplateName { get; set; }

        /// <summary>
        /// Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path.
        /// </summary>
        /// <value>Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path.</value>
        [DataMember(Name="shortestPathNetworkAttributeName", EmitDefaultValue=false)]
        public string ShortestPathNetworkAttributeName { get; set; }

        /// <summary>
        /// Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute.
        /// </summary>
        /// <value>Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute.</value>
        [DataMember(Name="filterBitsetNetworkAttributeName", EmitDefaultValue=false)]
        public string FilterBitsetNetworkAttributeName { get; set; }


        /// <summary>
        /// Gets or Sets FilterScope
        /// </summary>
        [DataMember(Name="filterScope", EmitDefaultValue=false)]
        public string FilterScope { get; set; }

        /// <summary>
        /// Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute.
        /// </summary>
        /// <value>Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute.</value>
        [DataMember(Name="conditionBarriers", EmitDefaultValue=false)]
        public List<ConditionBarrier> ConditionBarriers { get; set; }

        /// <summary>
        /// optional parameter.
        /// </summary>
        /// <value>optional parameter.</value>
        [DataMember(Name="functionBarriers", EmitDefaultValue=false)]
        public List<FunctionBarrier> FunctionBarriers { get; set; }

        /// <summary>
        /// The categories that serve as barriers (default is none) : optional parameter.
        /// </summary>
        /// <value>The categories that serve as barriers (default is none) : optional parameter.</value>
        [DataMember(Name="categoryBarriers", EmitDefaultValue=false)]
        public List<string> CategoryBarriers { get; set; }

        /// <summary>
        /// A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter.
        /// </summary>
        /// <value>A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter.</value>
        [DataMember(Name="filterBarriers", EmitDefaultValue=false)]
        public List<string> FilterBarriers { get; set; }

        /// <summary>
        /// Gets or Sets FilterFunctionBarriers
        /// </summary>
        [DataMember(Name="filterFunctionBarriers", EmitDefaultValue=false)]
        public List<string> FilterFunctionBarriers { get; set; }

        /// <summary>
        /// Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions.
        /// </summary>
        /// <value>Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions.</value>
        [DataMember(Name="functions", EmitDefaultValue=false)]
        public Object Functions { get; set; }

        /// <summary>
        /// Gets or Sets NearestNeighbor
        /// </summary>
        [DataMember(Name="nearestNeighbor", EmitDefaultValue=false)]
        public NearestNeighborParam NearestNeighbor { get; set; }

        /// <summary>
        /// Optional property. This is an array of objects representing categories associated with the output filter (the default is none).
        /// </summary>
        /// <value>Optional property. This is an array of objects representing categories associated with the output filter (the default is none).</value>
        [DataMember(Name="outputFilterCategories", EmitDefaultValue=false)]
        public Object OutputFilterCategories { get; set; }

        /// <summary>
        /// Optional property representing the output filter; an array of objects (default is null).
        /// </summary>
        /// <value>Optional property representing the output filter; an array of objects (default is null).</value>
        [DataMember(Name="outputFilters", EmitDefaultValue=false)]
        public List<OutputFilter> OutputFilters { get; set; }

        /// <summary>
        /// Optional property specifying the type of features returned based on a network attribute or category.
        /// </summary>
        /// <value>Optional property specifying the type of features returned based on a network attribute or category.</value>
        [DataMember(Name="outputConditions", EmitDefaultValue=false)]
        public List<TraceOutputCondition> OutputConditions { get; set; }

        /// <summary>
        /// Gets or Sets ArcadeExpressionBarrier
        /// </summary>
        [DataMember(Name="arcadeExpressionBarrier", EmitDefaultValue=false)]
        public string ArcadeExpressionBarrier { get; set; }

        /// <summary>
        /// Gets or Sets Propagators
        /// </summary>
        [DataMember(Name="propagators", EmitDefaultValue=false)]
        public List<Propagator> Propagators { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TraceConfiguration {\n");
            sb.Append("  IncludeContainers: ").Append(IncludeContainers).Append("\n");
            sb.Append("  IncludeContent: ").Append(IncludeContent).Append("\n");
            sb.Append("  IncludeStructures: ").Append(IncludeStructures).Append("\n");
            sb.Append("  IncludeBarriers: ").Append(IncludeBarriers).Append("\n");
            sb.Append("  ValidateConsistency: ").Append(ValidateConsistency).Append("\n");
            sb.Append("  IncludeIsolated: ").Append(IncludeIsolated).Append("\n");
            sb.Append("  IgnoreBarriersAtStartingPoints: ").Append(IgnoreBarriersAtStartingPoints).Append("\n");
            sb.Append("  IncludeUpToFirstSpatialContainer: ").Append(IncludeUpToFirstSpatialContainer).Append("\n");
            sb.Append("  DomainNetworkName: ").Append(DomainNetworkName).Append("\n");
            sb.Append("  TierName: ").Append(TierName).Append("\n");
            sb.Append("  TargetTierName: ").Append(TargetTierName).Append("\n");
            sb.Append("  SubnetworkName: ").Append(SubnetworkName).Append("\n");
            sb.Append("  DiagramTemplateName: ").Append(DiagramTemplateName).Append("\n");
            sb.Append("  ShortestPathNetworkAttributeName: ").Append(ShortestPathNetworkAttributeName).Append("\n");
            sb.Append("  FilterBitsetNetworkAttributeName: ").Append(FilterBitsetNetworkAttributeName).Append("\n");
            sb.Append("  TraversabilityScope: ").Append(TraversabilityScope).Append("\n");
            sb.Append("  FilterScope: ").Append(FilterScope).Append("\n");
            sb.Append("  ConditionBarriers: ").Append(ConditionBarriers).Append("\n");
            sb.Append("  FunctionBarriers: ").Append(FunctionBarriers).Append("\n");
            sb.Append("  CategoryBarriers: ").Append(CategoryBarriers).Append("\n");
            sb.Append("  FilterBarriers: ").Append(FilterBarriers).Append("\n");
            sb.Append("  FilterFunctionBarriers: ").Append(FilterFunctionBarriers).Append("\n");
            sb.Append("  Functions: ").Append(Functions).Append("\n");
            sb.Append("  NearestNeighbor: ").Append(NearestNeighbor).Append("\n");
            sb.Append("  OutputFilterCategories: ").Append(OutputFilterCategories).Append("\n");
            sb.Append("  OutputFilters: ").Append(OutputFilters).Append("\n");
            sb.Append("  OutputConditions: ").Append(OutputConditions).Append("\n");
            sb.Append("  ArcadeExpressionBarrier: ").Append(ArcadeExpressionBarrier).Append("\n");
            sb.Append("  Propagators: ").Append(Propagators).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TraceConfiguration);
        }

        /// <summary>
        /// Returns true if TraceConfiguration instances are equal
        /// </summary>
        /// <param name="input">Instance of TraceConfiguration to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TraceConfiguration input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.IncludeContainers == input.IncludeContainers ||
                    (this.IncludeContainers != null &&
                    this.IncludeContainers.Equals(input.IncludeContainers))
                ) && 
                (
                    this.IncludeContent == input.IncludeContent ||
                    (this.IncludeContent != null &&
                    this.IncludeContent.Equals(input.IncludeContent))
                ) && 
                (
                    this.IncludeStructures == input.IncludeStructures ||
                    (this.IncludeStructures != null &&
                    this.IncludeStructures.Equals(input.IncludeStructures))
                ) && 
                (
                    this.IncludeBarriers == input.IncludeBarriers ||
                    (this.IncludeBarriers != null &&
                    this.IncludeBarriers.Equals(input.IncludeBarriers))
                ) && 
                (
                    this.ValidateConsistency == input.ValidateConsistency ||
                    (this.ValidateConsistency != null &&
                    this.ValidateConsistency.Equals(input.ValidateConsistency))
                ) && 
                (
                    this.IncludeIsolated == input.IncludeIsolated ||
                    (this.IncludeIsolated != null &&
                    this.IncludeIsolated.Equals(input.IncludeIsolated))
                ) && 
                (
                    this.IgnoreBarriersAtStartingPoints == input.IgnoreBarriersAtStartingPoints ||
                    (this.IgnoreBarriersAtStartingPoints != null &&
                    this.IgnoreBarriersAtStartingPoints.Equals(input.IgnoreBarriersAtStartingPoints))
                ) && 
                (
                    this.IncludeUpToFirstSpatialContainer == input.IncludeUpToFirstSpatialContainer ||
                    (this.IncludeUpToFirstSpatialContainer != null &&
                    this.IncludeUpToFirstSpatialContainer.Equals(input.IncludeUpToFirstSpatialContainer))
                ) && 
                (
                    this.DomainNetworkName == input.DomainNetworkName ||
                    (this.DomainNetworkName != null &&
                    this.DomainNetworkName.Equals(input.DomainNetworkName))
                ) && 
                (
                    this.TierName == input.TierName ||
                    (this.TierName != null &&
                    this.TierName.Equals(input.TierName))
                ) && 
                (
                    this.TargetTierName == input.TargetTierName ||
                    (this.TargetTierName != null &&
                    this.TargetTierName.Equals(input.TargetTierName))
                ) && 
                (
                    this.SubnetworkName == input.SubnetworkName ||
                    (this.SubnetworkName != null &&
                    this.SubnetworkName.Equals(input.SubnetworkName))
                ) && 
                (
                    this.DiagramTemplateName == input.DiagramTemplateName ||
                    (this.DiagramTemplateName != null &&
                    this.DiagramTemplateName.Equals(input.DiagramTemplateName))
                ) && 
                (
                    this.ShortestPathNetworkAttributeName == input.ShortestPathNetworkAttributeName ||
                    (this.ShortestPathNetworkAttributeName != null &&
                    this.ShortestPathNetworkAttributeName.Equals(input.ShortestPathNetworkAttributeName))
                ) && 
                (
                    this.FilterBitsetNetworkAttributeName == input.FilterBitsetNetworkAttributeName ||
                    (this.FilterBitsetNetworkAttributeName != null &&
                    this.FilterBitsetNetworkAttributeName.Equals(input.FilterBitsetNetworkAttributeName))
                ) && 
                (
                    this.TraversabilityScope == input.TraversabilityScope ||
                    (this.TraversabilityScope != null &&
                    this.TraversabilityScope.Equals(input.TraversabilityScope))
                ) && 
                (
                    this.FilterScope == input.FilterScope ||
                    (this.FilterScope != null &&
                    this.FilterScope.Equals(input.FilterScope))
                ) && 
                (
                    this.ConditionBarriers == input.ConditionBarriers ||
                    this.ConditionBarriers != null &&
                    input.ConditionBarriers != null &&
                    this.ConditionBarriers.SequenceEqual(input.ConditionBarriers)
                ) && 
                (
                    this.FunctionBarriers == input.FunctionBarriers ||
                    this.FunctionBarriers != null &&
                    input.FunctionBarriers != null &&
                    this.FunctionBarriers.SequenceEqual(input.FunctionBarriers)
                ) && 
                (
                    this.CategoryBarriers == input.CategoryBarriers ||
                    this.CategoryBarriers != null &&
                    input.CategoryBarriers != null &&
                    this.CategoryBarriers.SequenceEqual(input.CategoryBarriers)
                ) && 
                (
                    this.FilterBarriers == input.FilterBarriers ||
                    this.FilterBarriers != null &&
                    input.FilterBarriers != null &&
                    this.FilterBarriers.SequenceEqual(input.FilterBarriers)
                ) && 
                (
                    this.FilterFunctionBarriers == input.FilterFunctionBarriers ||
                    this.FilterFunctionBarriers != null &&
                    input.FilterFunctionBarriers != null &&
                    this.FilterFunctionBarriers.SequenceEqual(input.FilterFunctionBarriers)
                ) && 
                (
                    this.Functions == input.Functions ||
                    (this.Functions != null &&
                    this.Functions.Equals(input.Functions))
                ) && 
                (
                    this.NearestNeighbor == input.NearestNeighbor ||
                    (this.NearestNeighbor != null &&
                    this.NearestNeighbor.Equals(input.NearestNeighbor))
                ) && 
                (
                    this.OutputFilterCategories == input.OutputFilterCategories ||
                    (this.OutputFilterCategories != null &&
                    this.OutputFilterCategories.Equals(input.OutputFilterCategories))
                ) && 
                (
                    this.OutputFilters == input.OutputFilters ||
                    this.OutputFilters != null &&
                    input.OutputFilters != null &&
                    this.OutputFilters.SequenceEqual(input.OutputFilters)
                ) && 
                (
                    this.OutputConditions == input.OutputConditions ||
                    this.OutputConditions != null &&
                    input.OutputConditions != null &&
                    this.OutputConditions.SequenceEqual(input.OutputConditions)
                ) && 
                (
                    this.ArcadeExpressionBarrier == input.ArcadeExpressionBarrier ||
                    (this.ArcadeExpressionBarrier != null &&
                    this.ArcadeExpressionBarrier.Equals(input.ArcadeExpressionBarrier))
                ) && 
                (
                    this.Propagators == input.Propagators ||
                    this.Propagators != null &&
                    input.Propagators != null &&
                    this.Propagators.SequenceEqual(input.Propagators)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.IncludeContainers != null)
                    hashCode = hashCode * 59 + this.IncludeContainers.GetHashCode();
                if (this.IncludeContent != null)
                    hashCode = hashCode * 59 + this.IncludeContent.GetHashCode();
                if (this.IncludeStructures != null)
                    hashCode = hashCode * 59 + this.IncludeStructures.GetHashCode();
                if (this.IncludeBarriers != null)
                    hashCode = hashCode * 59 + this.IncludeBarriers.GetHashCode();
                if (this.ValidateConsistency != null)
                    hashCode = hashCode * 59 + this.ValidateConsistency.GetHashCode();
                if (this.IncludeIsolated != null)
                    hashCode = hashCode * 59 + this.IncludeIsolated.GetHashCode();
                if (this.IgnoreBarriersAtStartingPoints != null)
                    hashCode = hashCode * 59 + this.IgnoreBarriersAtStartingPoints.GetHashCode();
                if (this.IncludeUpToFirstSpatialContainer != null)
                    hashCode = hashCode * 59 + this.IncludeUpToFirstSpatialContainer.GetHashCode();
                if (this.DomainNetworkName != null)
                    hashCode = hashCode * 59 + this.DomainNetworkName.GetHashCode();
                if (this.TierName != null)
                    hashCode = hashCode * 59 + this.TierName.GetHashCode();
                if (this.TargetTierName != null)
                    hashCode = hashCode * 59 + this.TargetTierName.GetHashCode();
                if (this.SubnetworkName != null)
                    hashCode = hashCode * 59 + this.SubnetworkName.GetHashCode();
                if (this.DiagramTemplateName != null)
                    hashCode = hashCode * 59 + this.DiagramTemplateName.GetHashCode();
                if (this.ShortestPathNetworkAttributeName != null)
                    hashCode = hashCode * 59 + this.ShortestPathNetworkAttributeName.GetHashCode();
                if (this.FilterBitsetNetworkAttributeName != null)
                    hashCode = hashCode * 59 + this.FilterBitsetNetworkAttributeName.GetHashCode();
                if (this.TraversabilityScope != null)
                    hashCode = hashCode * 59 + this.TraversabilityScope.GetHashCode();
                if (this.FilterScope != null)
                    hashCode = hashCode * 59 + this.FilterScope.GetHashCode();
                if (this.ConditionBarriers != null)
                    hashCode = hashCode * 59 + this.ConditionBarriers.GetHashCode();
                if (this.FunctionBarriers != null)
                    hashCode = hashCode * 59 + this.FunctionBarriers.GetHashCode();
                if (this.CategoryBarriers != null)
                    hashCode = hashCode * 59 + this.CategoryBarriers.GetHashCode();
                if (this.FilterBarriers != null)
                    hashCode = hashCode * 59 + this.FilterBarriers.GetHashCode();
                if (this.FilterFunctionBarriers != null)
                    hashCode = hashCode * 59 + this.FilterFunctionBarriers.GetHashCode();
                if (this.Functions != null)
                    hashCode = hashCode * 59 + this.Functions.GetHashCode();
                if (this.NearestNeighbor != null)
                    hashCode = hashCode * 59 + this.NearestNeighbor.GetHashCode();
                if (this.OutputFilterCategories != null)
                    hashCode = hashCode * 59 + this.OutputFilterCategories.GetHashCode();
                if (this.OutputFilters != null)
                    hashCode = hashCode * 59 + this.OutputFilters.GetHashCode();
                if (this.OutputConditions != null)
                    hashCode = hashCode * 59 + this.OutputConditions.GetHashCode();
                if (this.ArcadeExpressionBarrier != null)
                    hashCode = hashCode * 59 + this.ArcadeExpressionBarrier.GetHashCode();
                if (this.Propagators != null)
                    hashCode = hashCode * 59 + this.Propagators.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
