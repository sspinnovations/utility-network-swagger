# coding: utf-8

"""
    Swagger for Utility Network

    Open API Specification (OAS/Swagger)  * **trace**, **updateIsConnected** from the [ArcGIS Utility Network](https://developers.arcgis.com/rest/services-reference/utility-network-service.htm) * **generateToken** from the [ArcGIS REST API](https://developers.arcgis.com/rest/)  Tested on ArcGIS  Enterprise 10.8.1 using OpenAPI Specification (OAC) written in [SwaggerEditor](https://github.com/swagger-api/swagger-editor)   and [SwaggerHub](https://app.swaggerhub.com/) for C# and Typescript-Angular code generation.    # noqa: E501

    OpenAPI spec version: 3.0
    Contact: kim.sundeen@sspinnovations.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class TraceConfiguration(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'include_containers': 'bool',
        'include_content': 'bool',
        'include_structures': 'bool',
        'include_barriers': 'bool',
        'validate_consistency': 'bool',
        'include_isolated': 'bool',
        'ignore_barriers_at_starting_points': 'bool',
        'include_up_to_first_spatial_container': 'bool',
        'domain_network_name': 'str',
        'tier_name': 'str',
        'target_tier_name': 'str',
        'subnetwork_name': 'str',
        'diagram_template_name': 'str',
        'shortest_path_network_attribute_name': 'str',
        'filter_bitset_network_attribute_name': 'str',
        'traversability_scope': 'str',
        'filter_scope': 'str',
        'condition_barriers': 'list[ConditionBarrier]',
        'function_barriers': 'list[FunctionBarrier]',
        'category_barriers': 'list[str]',
        'filter_barriers': 'list[str]',
        'filter_function_barriers': 'list[str]',
        'functions': 'object',
        'nearest_neighbor': 'NearestNeighborParam',
        'output_filter_categories': 'object',
        'output_filters': 'list[OutputFilter]',
        'output_conditions': 'list[TraceOutputCondition]',
        'arcade_expression_barrier': 'str',
        'propagators': 'list[Propagator]'
    }

    attribute_map = {
        'include_containers': 'includeContainers',
        'include_content': 'includeContent',
        'include_structures': 'includeStructures',
        'include_barriers': 'includeBarriers',
        'validate_consistency': 'validateConsistency',
        'include_isolated': 'includeIsolated',
        'ignore_barriers_at_starting_points': 'ignoreBarriersAtStartingPoints',
        'include_up_to_first_spatial_container': 'includeUpToFirstSpatialContainer',
        'domain_network_name': 'domainNetworkName',
        'tier_name': 'tierName',
        'target_tier_name': 'targetTierName',
        'subnetwork_name': 'subnetworkName',
        'diagram_template_name': 'diagramTemplateName',
        'shortest_path_network_attribute_name': 'shortestPathNetworkAttributeName',
        'filter_bitset_network_attribute_name': 'filterBitsetNetworkAttributeName',
        'traversability_scope': 'traversabilityScope',
        'filter_scope': 'filterScope',
        'condition_barriers': 'conditionBarriers',
        'function_barriers': 'functionBarriers',
        'category_barriers': 'categoryBarriers',
        'filter_barriers': 'filterBarriers',
        'filter_function_barriers': 'filterFunctionBarriers',
        'functions': 'functions',
        'nearest_neighbor': 'nearestNeighbor',
        'output_filter_categories': 'outputFilterCategories',
        'output_filters': 'outputFilters',
        'output_conditions': 'outputConditions',
        'arcade_expression_barrier': 'arcadeExpressionBarrier',
        'propagators': 'propagators'
    }

    def __init__(self, include_containers=False, include_content=False, include_structures=False, include_barriers=True, validate_consistency=False, include_isolated=False, ignore_barriers_at_starting_points=False, include_up_to_first_spatial_container=False, domain_network_name='', tier_name='', target_tier_name='', subnetwork_name='', diagram_template_name='', shortest_path_network_attribute_name='', filter_bitset_network_attribute_name='', traversability_scope='junctionsAndEdges', filter_scope='junctionsAndEdges', condition_barriers=None, function_barriers=None, category_barriers=None, filter_barriers=None, filter_function_barriers=None, functions=None, nearest_neighbor=None, output_filter_categories=None, output_filters=None, output_conditions=None, arcade_expression_barrier='', propagators=None):  # noqa: E501
        """TraceConfiguration - a model defined in Swagger"""  # noqa: E501
        self._include_containers = None
        self._include_content = None
        self._include_structures = None
        self._include_barriers = None
        self._validate_consistency = None
        self._include_isolated = None
        self._ignore_barriers_at_starting_points = None
        self._include_up_to_first_spatial_container = None
        self._domain_network_name = None
        self._tier_name = None
        self._target_tier_name = None
        self._subnetwork_name = None
        self._diagram_template_name = None
        self._shortest_path_network_attribute_name = None
        self._filter_bitset_network_attribute_name = None
        self._traversability_scope = None
        self._filter_scope = None
        self._condition_barriers = None
        self._function_barriers = None
        self._category_barriers = None
        self._filter_barriers = None
        self._filter_function_barriers = None
        self._functions = None
        self._nearest_neighbor = None
        self._output_filter_categories = None
        self._output_filters = None
        self._output_conditions = None
        self._arcade_expression_barrier = None
        self._propagators = None
        self.discriminator = None
        if include_containers is not None:
            self.include_containers = include_containers
        if include_content is not None:
            self.include_content = include_content
        if include_structures is not None:
            self.include_structures = include_structures
        if include_barriers is not None:
            self.include_barriers = include_barriers
        if validate_consistency is not None:
            self.validate_consistency = validate_consistency
        if include_isolated is not None:
            self.include_isolated = include_isolated
        if ignore_barriers_at_starting_points is not None:
            self.ignore_barriers_at_starting_points = ignore_barriers_at_starting_points
        if include_up_to_first_spatial_container is not None:
            self.include_up_to_first_spatial_container = include_up_to_first_spatial_container
        if domain_network_name is not None:
            self.domain_network_name = domain_network_name
        if tier_name is not None:
            self.tier_name = tier_name
        if target_tier_name is not None:
            self.target_tier_name = target_tier_name
        if subnetwork_name is not None:
            self.subnetwork_name = subnetwork_name
        if diagram_template_name is not None:
            self.diagram_template_name = diagram_template_name
        if shortest_path_network_attribute_name is not None:
            self.shortest_path_network_attribute_name = shortest_path_network_attribute_name
        if filter_bitset_network_attribute_name is not None:
            self.filter_bitset_network_attribute_name = filter_bitset_network_attribute_name
        if traversability_scope is not None:
            self.traversability_scope = traversability_scope
        if filter_scope is not None:
            self.filter_scope = filter_scope
        self.condition_barriers = condition_barriers
        self.function_barriers = function_barriers
        if category_barriers is not None:
            self.category_barriers = category_barriers
        self.filter_barriers = filter_barriers
        self.filter_function_barriers = filter_function_barriers
        self.functions = functions
        self.nearest_neighbor = nearest_neighbor
        if output_filter_categories is not None:
            self.output_filter_categories = output_filter_categories
        self.output_filters = output_filters
        self.output_conditions = output_conditions
        if arcade_expression_barrier is not None:
            self.arcade_expression_barrier = arcade_expression_barrier
        self.propagators = propagators

    @property
    def include_containers(self):
        """Gets the include_containers of this TraceConfiguration.  # noqa: E501

        Optional parameter representing whether or not to include containers in the trace result (default is false).  # noqa: E501

        :return: The include_containers of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._include_containers

    @include_containers.setter
    def include_containers(self, include_containers):
        """Sets the include_containers of this TraceConfiguration.

        Optional parameter representing whether or not to include containers in the trace result (default is false).  # noqa: E501

        :param include_containers: The include_containers of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._include_containers = include_containers

    @property
    def include_content(self):
        """Gets the include_content of this TraceConfiguration.  # noqa: E501

        Optional parameter representing whether or not to include content in the trace result (default is false).  # noqa: E501

        :return: The include_content of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._include_content

    @include_content.setter
    def include_content(self, include_content):
        """Sets the include_content of this TraceConfiguration.

        Optional parameter representing whether or not to include content in the trace result (default is false).  # noqa: E501

        :param include_content: The include_content of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._include_content = include_content

    @property
    def include_structures(self):
        """Gets the include_structures of this TraceConfiguration.  # noqa: E501

        Optional parameter representing whether or not to include structures in the trace result (default is false).  # noqa: E501

        :return: The include_structures of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._include_structures

    @include_structures.setter
    def include_structures(self, include_structures):
        """Sets the include_structures of this TraceConfiguration.

        Optional parameter representing whether or not to include structures in the trace result (default is false).  # noqa: E501

        :param include_structures: The include_structures of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._include_structures = include_structures

    @property
    def include_barriers(self):
        """Gets the include_barriers of this TraceConfiguration.  # noqa: E501

        Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true).  # noqa: E501

        :return: The include_barriers of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._include_barriers

    @include_barriers.setter
    def include_barriers(self, include_barriers):
        """Sets the include_barriers of this TraceConfiguration.

        Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true).  # noqa: E501

        :param include_barriers: The include_barriers of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._include_barriers = include_barriers

    @property
    def validate_consistency(self):
        """Gets the validate_consistency of this TraceConfiguration.  # noqa: E501

        Optional parameter representing whether or not to validate the consistency of the trace results (default is false).  # noqa: E501

        :return: The validate_consistency of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._validate_consistency

    @validate_consistency.setter
    def validate_consistency(self, validate_consistency):
        """Sets the validate_consistency of this TraceConfiguration.

        Optional parameter representing whether or not to validate the consistency of the trace results (default is false).  # noqa: E501

        :param validate_consistency: The validate_consistency of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._validate_consistency = validate_consistency

    @property
    def include_isolated(self):
        """Gets the include_isolated of this TraceConfiguration.  # noqa: E501

        Optional property specifying whether to include isolated features for an isolation trace (the default is false).  # noqa: E501

        :return: The include_isolated of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._include_isolated

    @include_isolated.setter
    def include_isolated(self, include_isolated):
        """Sets the include_isolated of this TraceConfiguration.

        Optional property specifying whether to include isolated features for an isolation trace (the default is false).  # noqa: E501

        :param include_isolated: The include_isolated of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._include_isolated = include_isolated

    @property
    def ignore_barriers_at_starting_points(self):
        """Gets the ignore_barriers_at_starting_points of this TraceConfiguration.  # noqa: E501

        Optional property specifying whether dynamic barriers in the trace configuration are ignored for starting points. This can be useful when performing an upstream protective device trace using the discovered protective devices (barriers) as starting points to find subsequent upstream protective devices (the default is false).  # noqa: E501

        :return: The ignore_barriers_at_starting_points of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._ignore_barriers_at_starting_points

    @ignore_barriers_at_starting_points.setter
    def ignore_barriers_at_starting_points(self, ignore_barriers_at_starting_points):
        """Sets the ignore_barriers_at_starting_points of this TraceConfiguration.

        Optional property specifying whether dynamic barriers in the trace configuration are ignored for starting points. This can be useful when performing an upstream protective device trace using the discovered protective devices (barriers) as starting points to find subsequent upstream protective devices (the default is false).  # noqa: E501

        :param ignore_barriers_at_starting_points: The ignore_barriers_at_starting_points of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._ignore_barriers_at_starting_points = ignore_barriers_at_starting_points

    @property
    def include_up_to_first_spatial_container(self):
        """Gets the include_up_to_first_spatial_container of this TraceConfiguration.  # noqa: E501

        Optional property representing whether to limit the containers returned in the trace result. This property depends on the includeContainers property and no-ops if includeContainers is false. If includeContainers is true and this property is true, containment associations up to, and including the first spatial container will be returned; otherwise all containment associations will be returned (the default is false).  # noqa: E501

        :return: The include_up_to_first_spatial_container of this TraceConfiguration.  # noqa: E501
        :rtype: bool
        """
        return self._include_up_to_first_spatial_container

    @include_up_to_first_spatial_container.setter
    def include_up_to_first_spatial_container(self, include_up_to_first_spatial_container):
        """Sets the include_up_to_first_spatial_container of this TraceConfiguration.

        Optional property representing whether to limit the containers returned in the trace result. This property depends on the includeContainers property and no-ops if includeContainers is false. If includeContainers is true and this property is true, containment associations up to, and including the first spatial container will be returned; otherwise all containment associations will be returned (the default is false).  # noqa: E501

        :param include_up_to_first_spatial_container: The include_up_to_first_spatial_container of this TraceConfiguration.  # noqa: E501
        :type: bool
        """

        self._include_up_to_first_spatial_container = include_up_to_first_spatial_container

    @property
    def domain_network_name(self):
        """Gets the domain_network_name of this TraceConfiguration.  # noqa: E501

        Specifies the name of the domain network where the trace is starting. This is required for subnetwork-based traces.  # noqa: E501

        :return: The domain_network_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._domain_network_name

    @domain_network_name.setter
    def domain_network_name(self, domain_network_name):
        """Sets the domain_network_name of this TraceConfiguration.

        Specifies the name of the domain network where the trace is starting. This is required for subnetwork-based traces.  # noqa: E501

        :param domain_network_name: The domain_network_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._domain_network_name = domain_network_name

    @property
    def tier_name(self):
        """Gets the tier_name of this TraceConfiguration.  # noqa: E501

        Optional parameter that specifies the name of the tier where the trace is starting.  # noqa: E501

        :return: The tier_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._tier_name

    @tier_name.setter
    def tier_name(self, tier_name):
        """Sets the tier_name of this TraceConfiguration.

        Optional parameter that specifies the name of the tier where the trace is starting.  # noqa: E501

        :param tier_name: The tier_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._tier_name = tier_name

    @property
    def target_tier_name(self):
        """Gets the target_tier_name of this TraceConfiguration.  # noqa: E501

        Optional parameter representing the name of the tier where upstream or downstream trace ends.  # noqa: E501

        :return: The target_tier_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._target_tier_name

    @target_tier_name.setter
    def target_tier_name(self, target_tier_name):
        """Sets the target_tier_name of this TraceConfiguration.

        Optional parameter representing the name of the tier where upstream or downstream trace ends.  # noqa: E501

        :param target_tier_name: The target_tier_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._target_tier_name = target_tier_name

    @property
    def subnetwork_name(self):
        """Gets the subnetwork_name of this TraceConfiguration.  # noqa: E501

        Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork .  # noqa: E501

        :return: The subnetwork_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._subnetwork_name

    @subnetwork_name.setter
    def subnetwork_name(self, subnetwork_name):
        """Sets the subnetwork_name of this TraceConfiguration.

        Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork .  # noqa: E501

        :param subnetwork_name: The subnetwork_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._subnetwork_name = subnetwork_name

    @property
    def diagram_template_name(self):
        """Gets the diagram_template_name of this TraceConfiguration.  # noqa: E501

        Optional parameter representing the name of the diagram template.  # noqa: E501

        :return: The diagram_template_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._diagram_template_name

    @diagram_template_name.setter
    def diagram_template_name(self, diagram_template_name):
        """Sets the diagram_template_name of this TraceConfiguration.

        Optional parameter representing the name of the diagram template.  # noqa: E501

        :param diagram_template_name: The diagram_template_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._diagram_template_name = diagram_template_name

    @property
    def shortest_path_network_attribute_name(self):
        """Gets the shortest_path_network_attribute_name of this TraceConfiguration.  # noqa: E501

        Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path.  # noqa: E501

        :return: The shortest_path_network_attribute_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._shortest_path_network_attribute_name

    @shortest_path_network_attribute_name.setter
    def shortest_path_network_attribute_name(self, shortest_path_network_attribute_name):
        """Sets the shortest_path_network_attribute_name of this TraceConfiguration.

        Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path.  # noqa: E501

        :param shortest_path_network_attribute_name: The shortest_path_network_attribute_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._shortest_path_network_attribute_name = shortest_path_network_attribute_name

    @property
    def filter_bitset_network_attribute_name(self):
        """Gets the filter_bitset_network_attribute_name of this TraceConfiguration.  # noqa: E501

        Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute.  # noqa: E501

        :return: The filter_bitset_network_attribute_name of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._filter_bitset_network_attribute_name

    @filter_bitset_network_attribute_name.setter
    def filter_bitset_network_attribute_name(self, filter_bitset_network_attribute_name):
        """Sets the filter_bitset_network_attribute_name of this TraceConfiguration.

        Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute.  # noqa: E501

        :param filter_bitset_network_attribute_name: The filter_bitset_network_attribute_name of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._filter_bitset_network_attribute_name = filter_bitset_network_attribute_name

    @property
    def traversability_scope(self):
        """Gets the traversability_scope of this TraceConfiguration.  # noqa: E501

        Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).  # noqa: E501

        :return: The traversability_scope of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._traversability_scope

    @traversability_scope.setter
    def traversability_scope(self, traversability_scope):
        """Sets the traversability_scope of this TraceConfiguration.

        Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).  # noqa: E501

        :param traversability_scope: The traversability_scope of this TraceConfiguration.  # noqa: E501
        :type: str
        """
        allowed_values = ["junctions", "edges", "junctionsAndEdges"]  # noqa: E501
        if traversability_scope not in allowed_values:
            raise ValueError(
                "Invalid value for `traversability_scope` ({0}), must be one of {1}"  # noqa: E501
                .format(traversability_scope, allowed_values)
            )

        self._traversability_scope = traversability_scope

    @property
    def filter_scope(self):
        """Gets the filter_scope of this TraceConfiguration.  # noqa: E501


        :return: The filter_scope of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._filter_scope

    @filter_scope.setter
    def filter_scope(self, filter_scope):
        """Sets the filter_scope of this TraceConfiguration.


        :param filter_scope: The filter_scope of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._filter_scope = filter_scope

    @property
    def condition_barriers(self):
        """Gets the condition_barriers of this TraceConfiguration.  # noqa: E501

        Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute.  # noqa: E501

        :return: The condition_barriers of this TraceConfiguration.  # noqa: E501
        :rtype: list[ConditionBarrier]
        """
        return self._condition_barriers

    @condition_barriers.setter
    def condition_barriers(self, condition_barriers):
        """Sets the condition_barriers of this TraceConfiguration.

        Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute.  # noqa: E501

        :param condition_barriers: The condition_barriers of this TraceConfiguration.  # noqa: E501
        :type: list[ConditionBarrier]
        """
        if condition_barriers is None:
            raise ValueError("Invalid value for `condition_barriers`, must not be `None`")  # noqa: E501

        self._condition_barriers = condition_barriers

    @property
    def function_barriers(self):
        """Gets the function_barriers of this TraceConfiguration.  # noqa: E501

        optional parameter.  # noqa: E501

        :return: The function_barriers of this TraceConfiguration.  # noqa: E501
        :rtype: list[FunctionBarrier]
        """
        return self._function_barriers

    @function_barriers.setter
    def function_barriers(self, function_barriers):
        """Sets the function_barriers of this TraceConfiguration.

        optional parameter.  # noqa: E501

        :param function_barriers: The function_barriers of this TraceConfiguration.  # noqa: E501
        :type: list[FunctionBarrier]
        """
        if function_barriers is None:
            raise ValueError("Invalid value for `function_barriers`, must not be `None`")  # noqa: E501

        self._function_barriers = function_barriers

    @property
    def category_barriers(self):
        """Gets the category_barriers of this TraceConfiguration.  # noqa: E501

        The categories that serve as barriers (default is none) : optional parameter.  # noqa: E501

        :return: The category_barriers of this TraceConfiguration.  # noqa: E501
        :rtype: list[str]
        """
        return self._category_barriers

    @category_barriers.setter
    def category_barriers(self, category_barriers):
        """Sets the category_barriers of this TraceConfiguration.

        The categories that serve as barriers (default is none) : optional parameter.  # noqa: E501

        :param category_barriers: The category_barriers of this TraceConfiguration.  # noqa: E501
        :type: list[str]
        """

        self._category_barriers = category_barriers

    @property
    def filter_barriers(self):
        """Gets the filter_barriers of this TraceConfiguration.  # noqa: E501

        A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter.  # noqa: E501

        :return: The filter_barriers of this TraceConfiguration.  # noqa: E501
        :rtype: list[str]
        """
        return self._filter_barriers

    @filter_barriers.setter
    def filter_barriers(self, filter_barriers):
        """Sets the filter_barriers of this TraceConfiguration.

        A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter.  # noqa: E501

        :param filter_barriers: The filter_barriers of this TraceConfiguration.  # noqa: E501
        :type: list[str]
        """
        if filter_barriers is None:
            raise ValueError("Invalid value for `filter_barriers`, must not be `None`")  # noqa: E501

        self._filter_barriers = filter_barriers

    @property
    def filter_function_barriers(self):
        """Gets the filter_function_barriers of this TraceConfiguration.  # noqa: E501


        :return: The filter_function_barriers of this TraceConfiguration.  # noqa: E501
        :rtype: list[str]
        """
        return self._filter_function_barriers

    @filter_function_barriers.setter
    def filter_function_barriers(self, filter_function_barriers):
        """Sets the filter_function_barriers of this TraceConfiguration.


        :param filter_function_barriers: The filter_function_barriers of this TraceConfiguration.  # noqa: E501
        :type: list[str]
        """
        if filter_function_barriers is None:
            raise ValueError("Invalid value for `filter_function_barriers`, must not be `None`")  # noqa: E501

        self._filter_function_barriers = filter_function_barriers

    @property
    def functions(self):
        """Gets the functions of this TraceConfiguration.  # noqa: E501

        Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions.  # noqa: E501

        :return: The functions of this TraceConfiguration.  # noqa: E501
        :rtype: object
        """
        return self._functions

    @functions.setter
    def functions(self, functions):
        """Sets the functions of this TraceConfiguration.

        Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions.  # noqa: E501

        :param functions: The functions of this TraceConfiguration.  # noqa: E501
        :type: object
        """
        if functions is None:
            raise ValueError("Invalid value for `functions`, must not be `None`")  # noqa: E501

        self._functions = functions

    @property
    def nearest_neighbor(self):
        """Gets the nearest_neighbor of this TraceConfiguration.  # noqa: E501


        :return: The nearest_neighbor of this TraceConfiguration.  # noqa: E501
        :rtype: NearestNeighborParam
        """
        return self._nearest_neighbor

    @nearest_neighbor.setter
    def nearest_neighbor(self, nearest_neighbor):
        """Sets the nearest_neighbor of this TraceConfiguration.


        :param nearest_neighbor: The nearest_neighbor of this TraceConfiguration.  # noqa: E501
        :type: NearestNeighborParam
        """
        if nearest_neighbor is None:
            raise ValueError("Invalid value for `nearest_neighbor`, must not be `None`")  # noqa: E501

        self._nearest_neighbor = nearest_neighbor

    @property
    def output_filter_categories(self):
        """Gets the output_filter_categories of this TraceConfiguration.  # noqa: E501

        Optional property. This is an array of objects representing categories associated with the output filter (the default is none).  # noqa: E501

        :return: The output_filter_categories of this TraceConfiguration.  # noqa: E501
        :rtype: object
        """
        return self._output_filter_categories

    @output_filter_categories.setter
    def output_filter_categories(self, output_filter_categories):
        """Sets the output_filter_categories of this TraceConfiguration.

        Optional property. This is an array of objects representing categories associated with the output filter (the default is none).  # noqa: E501

        :param output_filter_categories: The output_filter_categories of this TraceConfiguration.  # noqa: E501
        :type: object
        """

        self._output_filter_categories = output_filter_categories

    @property
    def output_filters(self):
        """Gets the output_filters of this TraceConfiguration.  # noqa: E501

        Optional property representing the output filter; an array of objects (default is null).  # noqa: E501

        :return: The output_filters of this TraceConfiguration.  # noqa: E501
        :rtype: list[OutputFilter]
        """
        return self._output_filters

    @output_filters.setter
    def output_filters(self, output_filters):
        """Sets the output_filters of this TraceConfiguration.

        Optional property representing the output filter; an array of objects (default is null).  # noqa: E501

        :param output_filters: The output_filters of this TraceConfiguration.  # noqa: E501
        :type: list[OutputFilter]
        """
        if output_filters is None:
            raise ValueError("Invalid value for `output_filters`, must not be `None`")  # noqa: E501

        self._output_filters = output_filters

    @property
    def output_conditions(self):
        """Gets the output_conditions of this TraceConfiguration.  # noqa: E501

        Optional property specifying the type of features returned based on a network attribute or category.  # noqa: E501

        :return: The output_conditions of this TraceConfiguration.  # noqa: E501
        :rtype: list[TraceOutputCondition]
        """
        return self._output_conditions

    @output_conditions.setter
    def output_conditions(self, output_conditions):
        """Sets the output_conditions of this TraceConfiguration.

        Optional property specifying the type of features returned based on a network attribute or category.  # noqa: E501

        :param output_conditions: The output_conditions of this TraceConfiguration.  # noqa: E501
        :type: list[TraceOutputCondition]
        """
        if output_conditions is None:
            raise ValueError("Invalid value for `output_conditions`, must not be `None`")  # noqa: E501

        self._output_conditions = output_conditions

    @property
    def arcade_expression_barrier(self):
        """Gets the arcade_expression_barrier of this TraceConfiguration.  # noqa: E501


        :return: The arcade_expression_barrier of this TraceConfiguration.  # noqa: E501
        :rtype: str
        """
        return self._arcade_expression_barrier

    @arcade_expression_barrier.setter
    def arcade_expression_barrier(self, arcade_expression_barrier):
        """Sets the arcade_expression_barrier of this TraceConfiguration.


        :param arcade_expression_barrier: The arcade_expression_barrier of this TraceConfiguration.  # noqa: E501
        :type: str
        """

        self._arcade_expression_barrier = arcade_expression_barrier

    @property
    def propagators(self):
        """Gets the propagators of this TraceConfiguration.  # noqa: E501


        :return: The propagators of this TraceConfiguration.  # noqa: E501
        :rtype: list[Propagator]
        """
        return self._propagators

    @propagators.setter
    def propagators(self, propagators):
        """Sets the propagators of this TraceConfiguration.


        :param propagators: The propagators of this TraceConfiguration.  # noqa: E501
        :type: list[Propagator]
        """
        if propagators is None:
            raise ValueError("Invalid value for `propagators`, must not be `None`")  # noqa: E501

        self._propagators = propagators

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(TraceConfiguration, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, TraceConfiguration):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
