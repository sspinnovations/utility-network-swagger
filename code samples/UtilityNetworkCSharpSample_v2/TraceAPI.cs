//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."

namespace MyNamespace
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class Client
    {
        private string _baseUrl = "http://localhost/";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;

        public Client(System.Net.Http.HttpClient httpClient)
        {
            _httpClient = httpClient;
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(CreateSerializerSettings);
        }

        private Newtonsoft.Json.JsonSerializerSettings CreateSerializerSettings()
        {
            var settings = new Newtonsoft.Json.JsonSerializerSettings();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }

        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }

        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>updateIsConnected</summary>
        /// <returns>Status 200</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<UpdateIsConnectedResponse> UpdateIsConnectedAsync(string serverWebAdaptor, string utilityNetworkName, string f, string token, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (serverWebAdaptor == null)
                throw new System.ArgumentNullException("serverWebAdaptor");

            if (utilityNetworkName == null)
                throw new System.ArgumentNullException("utilityNetworkName");

            if (f == null)
                throw new System.ArgumentNullException("f");

            if (token == null)
                throw new System.ArgumentNullException("token");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/{ServerWebAdaptor}/rest/services/{UtilityNetworkName}/UtilityNetworkServer/updateIsConnected?");
            urlBuilder_.Replace("{ServerWebAdaptor}", System.Uri.EscapeDataString(ConvertToString(serverWebAdaptor, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{UtilityNetworkName}", System.Uri.EscapeDataString(ConvertToString(utilityNetworkName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("f") + "=").Append(System.Uri.EscapeDataString(ConvertToString(f, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Append(System.Uri.EscapeDataString("token") + "=").Append(System.Uri.EscapeDataString(ConvertToString(token, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Content = new System.Net.Http.StringContent(string.Empty, System.Text.Encoding.UTF8, "application/json");
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<UpdateIsConnectedResponse>(response_, headers_).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>trace</summary>
        /// <returns>OK</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TraceResultsSet> TraceAsync(string serverWebAdaptor, string utilityNetworkName, string token, Body body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (serverWebAdaptor == null)
                throw new System.ArgumentNullException("serverWebAdaptor");

            if (utilityNetworkName == null)
                throw new System.ArgumentNullException("utilityNetworkName");

            if (token == null)
                throw new System.ArgumentNullException("token");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/{ServerWebAdaptor}/rest/services/{UtilityNetworkName}/UtilityNetworkServer/trace?");
            urlBuilder_.Replace("{ServerWebAdaptor}", System.Uri.EscapeDataString(ConvertToString(serverWebAdaptor, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{UtilityNetworkName}", System.Uri.EscapeDataString(ConvertToString(utilityNetworkName, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Append(System.Uri.EscapeDataString("token") + "=").Append(System.Uri.EscapeDataString(ConvertToString(token, System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            urlBuilder_.Length--;

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    // -- Multipart for-data was used to send request -- //

                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (body.F == null)
                        throw new System.ArgumentNullException("f");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.F, System.Globalization.CultureInfo.InvariantCulture)), "f");
                    if (body.GdbVersion != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.GdbVersion, System.Globalization.CultureInfo.InvariantCulture)), "gdbVersion");
                    if (body.SessionId != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.SessionId, System.Globalization.CultureInfo.InvariantCulture)), "sessionId");
                    if (body.Moment != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.Moment, System.Globalization.CultureInfo.InvariantCulture)), "moment");
                    if (body.TraceType == null)
                        throw new System.ArgumentNullException("traceType");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.TraceType, System.Globalization.CultureInfo.InvariantCulture)), "traceType");
                    if (body.TraceLocations == null)
                        throw new System.ArgumentNullException("traceLocations");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.TraceLocations, System.Globalization.CultureInfo.InvariantCulture)), "traceLocations");
                    if (body.TraceConfiguration == null)
                        throw new System.ArgumentNullException("traceConfiguration");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.TraceConfiguration, System.Globalization.CultureInfo.InvariantCulture)), "traceConfiguration");
                    if (body.ResultTypes == null)
                        throw new System.ArgumentNullException("body.ResultTypes");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.ResultTypes, System.Globalization.CultureInfo.InvariantCulture)), "body.ResultTypes");

                    // -- Multipart for-data was used to send request -- //

                    //var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    //content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");

                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TraceResultsSet>(response_, headers_).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 404)
                        {
                            string responseText_ = (response_.Content == null) ? string.Empty : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("Tracing endpoint not found {base}/UtilityNetworkServer/trace", status_, responseText_, headers_, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>generateToken</summary>
        /// <returns>Status 200</returns>
        /// <exception cref="ApiException">A server side error occurred.</exception>
        public async System.Threading.Tasks.Task<TokenResponse> GenerateTokenAsync(string portalWebAdaptor, Body2 body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            if (portalWebAdaptor == null)
                throw new System.ArgumentNullException("portalWebAdaptor");

            if (body == null)
                throw new System.ArgumentNullException("body");

            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/{PortalWebAdaptor}/sharing/rest/generateToken");
            urlBuilder_.Replace("{PortalWebAdaptor}", System.Uri.EscapeDataString(ConvertToString(portalWebAdaptor, System.Globalization.CultureInfo.InvariantCulture)));

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {

                    // -- Multipart for-data was used to send request -- //

                    var boundary_ = System.Guid.NewGuid().ToString();
                    var content_ = new System.Net.Http.MultipartFormDataContent(boundary_);
                    content_.Headers.Remove("Content-Type");
                    content_.Headers.TryAddWithoutValidation("Content-Type", "multipart/form-data; boundary=" + boundary_);
                    if (body.Username == null)
                        throw new System.ArgumentNullException("username");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.Username, System.Globalization.CultureInfo.InvariantCulture)), "username");
                    if (body.Password == null)
                        throw new System.ArgumentNullException("password");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.Password, System.Globalization.CultureInfo.InvariantCulture)), "password");
                    if (body.Ip != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.Ip, System.Globalization.CultureInfo.InvariantCulture)), "ip");
                    if (body.Referer != null)
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.Referer, System.Globalization.CultureInfo.InvariantCulture)), "referer");
                    if (body.Expiration == null)
                        throw new System.ArgumentNullException("expiration");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.Expiration, System.Globalization.CultureInfo.InvariantCulture)), "expiration");
                    if (body.F == null)
                        throw new System.ArgumentNullException("f");
                    else
                        content_.Add(new System.Net.Http.StringContent(ConvertToString(body.F, System.Globalization.CultureInfo.InvariantCulture)), "f");

                    // -- Multipart for-data was used to send request -- //

                    //var content_ = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject(body, _settings.Value));
                    //content_.Headers.ContentType = System.Net.Http.Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded");

                    request_.Content = content_;
                    request_.Method = new System.Net.Http.HttpMethod("POST");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TokenResponse>(response_, headers_).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new ApiException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false);
                            throw new ApiException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await response.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    var typedBody = Newtonsoft.Json.JsonConvert.DeserializeObject<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))
                    using (var streamReader = new System.IO.StreamReader(responseStream))
                    using (var jsonTextReader = new Newtonsoft.Json.JsonTextReader(streamReader))
                    {
                        var serializer = Newtonsoft.Json.JsonSerializer.Create(JsonSerializerSettings);
                        var typedBody = serializer.Deserialize<T>(jsonTextReader);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (Newtonsoft.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new ApiException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return null;
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute))
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    return System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                }
            }
            else if (value is bool)
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[])value);
            }
            else if (value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array)value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return (result is null) ? string.Empty : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ConditionBarrier
    {
        [Newtonsoft.Json.JsonProperty("networkAttributeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NetworkAttributeName { get; set; }

        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Operator { get; set; }

        /// <summary>0 = unknown, 1 = open, 2 = closed</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        public double Value { get; set; }

        [Newtonsoft.Json.JsonProperty("combineUsingOr", Required = Newtonsoft.Json.Required.Always)]
        public bool CombineUsingOr { get; set; }

        [Newtonsoft.Json.JsonProperty("isTypeSpecificValue", Required = Newtonsoft.Json.Required.Always)]
        public bool IsTypeSpecificValue { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    /// <summary>Token reesponse from Portal</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TokenResponse
    {
        /// <summary>The generated token.</summary>
        [Newtonsoft.Json.JsonProperty("token", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Token { get; set; }

        /// <summary>The expiration time of the token in milliseconds since Jan. 1, 1970 (UTC).</summary>
        [Newtonsoft.Json.JsonProperty("expires", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Expires { get; set; }

        /// <summary>True if the token must always pass over ssl.</summary>
        [Newtonsoft.Json.JsonProperty("ssl", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Ssl { get; set; }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Error Error { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    /// <summary>Array of objects; optional parameter.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FunctionBarrier
    {
        /// <summary>Choose from a number of different calculation functions.</summary>
        [Newtonsoft.Json.JsonProperty("functionType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FunctionBarrierFunctionType FunctionType { get; set; }

        /// <summary>Choose to filter by any network attribute defined in the system.</summary>
        [Newtonsoft.Json.JsonProperty("networkAttributeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NetworkAttributeName { get; set; }

        /// <summary>Choose from a number of different operators</summary>
        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FunctionBarrierOperator Operator { get; set; }

        /// <summary>Specific value of the input attribute type that, if discovered, will cause the termination.(string (numeric)</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

        /// <summary>Calculates values in each direction as opposed to an overall global value.</summary>
        [Newtonsoft.Json.JsonProperty("useLocalValues", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool UseLocalValues { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Feature
    {
        /// <summary>networkSourceId</summary>
        [Newtonsoft.Json.JsonProperty("networkSourceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NetworkSourceId { get; set; }

        /// <summary>guid</summary>
        [Newtonsoft.Json.JsonProperty("globalId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GlobalId { get; set; }

        /// <summary>objectId</summary>
        [Newtonsoft.Json.JsonProperty("objectId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ObjectId { get; set; }

        /// <summary>terminalId</summary>
        [Newtonsoft.Json.JsonProperty("terminalId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TerminalId { get; set; }

        [Newtonsoft.Json.JsonProperty("networkAttributes", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<double> NetworkAttributes { get; set; }

        /// <summary>assetGroup</summary>
        [Newtonsoft.Json.JsonProperty("assetGroup", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double AssetGroup { get; set; }

        /// <summary>assetType</summary>
        [Newtonsoft.Json.JsonProperty("assetType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double AssetType { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Functions : System.Collections.ObjectModel.Collection<Anonymous>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OutputFilter
    {
        [Newtonsoft.Json.JsonProperty("sourceId", Required = Newtonsoft.Json.Required.Always)]
        public double SourceId { get; set; }

        [Newtonsoft.Json.JsonProperty("assetGroup", Required = Newtonsoft.Json.Required.Always)]
        public double AssetGroup { get; set; }

        [Newtonsoft.Json.JsonProperty("assetType", Required = Newtonsoft.Json.Required.Always)]
        public double AssetType { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceLocation
    {
        [Newtonsoft.Json.JsonProperty("traceLocationType", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceLocationType TraceLocationType { get; set; }

        [Newtonsoft.Json.JsonProperty("globalId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GlobalId { get; set; }

        [Newtonsoft.Json.JsonProperty("percentAlong", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double PercentAlong { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NetworkAttribute
    {
        [Newtonsoft.Json.JsonProperty("networkAttribute", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double NetworkAttribute1 { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Propagator
    {
        [Newtonsoft.Json.JsonProperty("networkAttributeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NetworkAttributeName { get; set; }

        [Newtonsoft.Json.JsonProperty("functionType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PropagatorFunctionType FunctionType { get; set; }

        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public PropagatorOperator Operator { get; set; }

        /// <summary>string (numeric)</summary>
        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Value { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceConfiguration
    {
        /// <summary>Optional parameter representing whether or not to include containers in the trace result (default is false).</summary>
        [Newtonsoft.Json.JsonProperty("includeContainers", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeContainers { get; set; } = false;

        /// <summary>Optional parameter representing whether or not to include content in the trace result (default is false).</summary>
        [Newtonsoft.Json.JsonProperty("includeContent", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeContent { get; set; } = false;

        /// <summary>Optional parameter representing whether or not to include structures in the trace result (default is false).</summary>
        [Newtonsoft.Json.JsonProperty("includeStructures", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeStructures { get; set; } = false;

        /// <summary>Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true).</summary>
        [Newtonsoft.Json.JsonProperty("includeBarriers", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeBarriers { get; set; } = true;

        /// <summary>Optional parameter representing whether or not to validate the consistency of the trace results (default is false).</summary>
        [Newtonsoft.Json.JsonProperty("validateConsistency", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool ValidateConsistency { get; set; } = false;

        /// <summary>Optional property specifying whether to include isolated features for an isolation trace (the default is false).</summary>
        [Newtonsoft.Json.JsonProperty("includeIsolated", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeIsolated { get; set; } = false;

        /// <summary>Optional property specifying whether dynamic barriers in the trace configuration are ignored for starting points. This can be useful when performing an upstream protective device trace using the discovered protective devices (barriers) as starting points to find subsequent upstream protective devices (the default is false).</summary>
        [Newtonsoft.Json.JsonProperty("ignoreBarriersAtStartingPoints", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IgnoreBarriersAtStartingPoints { get; set; } = false;

        /// <summary>Optional property representing whether to limit the containers returned in the trace result. This property depends on the includeContainers property and no-ops if includeContainers is false. If includeContainers is true and this property is true, containment associations up to, and including the first spatial container will be returned; otherwise all containment associations will be returned (the default is false).</summary>
        [Newtonsoft.Json.JsonProperty("includeUpToFirstSpatialContainer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IncludeUpToFirstSpatialContainer { get; set; } = false;

        /// <summary>Specifies the name of the domain network where the trace is starting. This is required for subnetwork-based traces.</summary>
        [Newtonsoft.Json.JsonProperty("domainNetworkName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DomainNetworkName { get; set; } = "";

        /// <summary>Optional parameter that specifies the name of the tier where the trace is starting.</summary>
        [Newtonsoft.Json.JsonProperty("tierName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TierName { get; set; } = "";

        /// <summary>Optional parameter representing the name of the tier where upstream or downstream trace ends.</summary>
        [Newtonsoft.Json.JsonProperty("targetTierName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TargetTierName { get; set; } = "";

        /// <summary>Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork .</summary>
        [Newtonsoft.Json.JsonProperty("subnetworkName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SubnetworkName { get; set; } = "";

        /// <summary>Optional parameter representing the name of the diagram template.</summary>
        [Newtonsoft.Json.JsonProperty("diagramTemplateName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DiagramTemplateName { get; set; } = "";

        /// <summary>Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path.</summary>
        [Newtonsoft.Json.JsonProperty("shortestPathNetworkAttributeName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ShortestPathNetworkAttributeName { get; set; } = "";

        /// <summary>Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute.</summary>
        [Newtonsoft.Json.JsonProperty("filterBitsetNetworkAttributeName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilterBitsetNetworkAttributeName { get; set; } = "";

        /// <summary>Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).</summary>
        [Newtonsoft.Json.JsonProperty("traversabilityScope", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceConfigurationTraversabilityScope TraversabilityScope { get; set; } = MyNamespace.TraceConfigurationTraversabilityScope.JunctionsAndEdges;

        [Newtonsoft.Json.JsonProperty("filterScope", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string FilterScope { get; set; } = "junctionsAndEdges";

        /// <summary>Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute.</summary>
        [Newtonsoft.Json.JsonProperty("conditionBarriers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<ConditionBarrier> ConditionBarriers { get; set; } = new System.Collections.ObjectModel.Collection<ConditionBarrier>();

        /// <summary>optional parameter.</summary>
        [Newtonsoft.Json.JsonProperty("functionBarriers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FunctionBarrier> FunctionBarriers { get; set; } = new System.Collections.ObjectModel.Collection<FunctionBarrier>();

        /// <summary>The categories that serve as barriers (default is none) : optional parameter.</summary>
        [Newtonsoft.Json.JsonProperty("categoryBarriers", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> CategoryBarriers { get; set; }

        /// <summary>A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter.</summary>
        [Newtonsoft.Json.JsonProperty("filterBarriers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> FilterBarriers { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        [Newtonsoft.Json.JsonProperty("filterFunctionBarriers", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> FilterFunctionBarriers { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        /// <summary>Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions.</summary>
        [Newtonsoft.Json.JsonProperty("functions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object Functions { get; set; } = new object();

        [Newtonsoft.Json.JsonProperty("nearestNeighbor", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public NearestNeighborParam NearestNeighbor { get; set; } = new NearestNeighborParam();

        /// <summary>Optional property. This is an array of objects representing categories associated with the output filter (the default is none).</summary>
        [Newtonsoft.Json.JsonProperty("outputFilterCategories", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public object OutputFilterCategories { get; set; }

        /// <summary>Optional property representing the output filter; an array of objects (default is null).</summary>
        [Newtonsoft.Json.JsonProperty("outputFilters", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OutputFilter> OutputFilters { get; set; } = new System.Collections.ObjectModel.Collection<OutputFilter>();

        /// <summary>Optional property specifying the type of features returned based on a network attribute or category.</summary>
        [Newtonsoft.Json.JsonProperty("outputConditions", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TraceOutputCondition> OutputConditions { get; set; } = new System.Collections.ObjectModel.Collection<TraceOutputCondition>();

        [Newtonsoft.Json.JsonProperty("arcadeExpressionBarrier", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string ArcadeExpressionBarrier { get; set; } = "";

        [Newtonsoft.Json.JsonProperty("propagators", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<Propagator> Propagators { get; set; } = new System.Collections.ObjectModel.Collection<Propagator>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceOutputCondition
    {
        [Newtonsoft.Json.JsonProperty("name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Name { get; set; }

        [Newtonsoft.Json.JsonProperty("type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TraceOutputConditionType Type { get; set; }

        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Operator { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Value { get; set; }

        [Newtonsoft.Json.JsonProperty("combineUsingOr", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CombineUsingOr { get; set; }

        [Newtonsoft.Json.JsonProperty("isSpecificValue", Required = Newtonsoft.Json.Required.Always)]
        public bool IsSpecificValue { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    /// <summary>Model for TraceResults</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceResultsSet
    {
        [Newtonsoft.Json.JsonProperty("traceResults", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public TraceResults TraceResults { get; set; }

        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool Success { get; set; }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Error2 Error { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TokenRequest
    {
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip { get; set; }

        [Newtonsoft.Json.JsonProperty("referer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Referer { get; set; }

        [Newtonsoft.Json.JsonProperty("expiration", Required = Newtonsoft.Json.Required.Always)]
        public double Expiration { get; set; }

        [Newtonsoft.Json.JsonProperty("f", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string F { get; set; } = "json";

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NearestNeighborParam
    {
        [Newtonsoft.Json.JsonProperty("count", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int Count { get; set; }

        [Newtonsoft.Json.JsonProperty("costNetworkAttributeName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string CostNetworkAttributeName { get; set; } = "";

        [Newtonsoft.Json.JsonProperty("nearestCategories", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> NearestCategories { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        [Newtonsoft.Json.JsonProperty("nearestAssets", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<string> NearestAssets { get; set; } = new System.Collections.ObjectModel.Collection<string>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceLocations : System.Collections.ObjectModel.Collection<TraceLocation>
    {

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class UpdateIsConnectedResponse
    {
        [Newtonsoft.Json.JsonProperty("moment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Moment { get; set; }

        [Newtonsoft.Json.JsonProperty("success", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Success { get; set; }

        [Newtonsoft.Json.JsonProperty("error", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Error3 Error { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Body
    {
        /// <summary>Optional parameter representing the output format of the response (default is JSON).</summary>
        [Newtonsoft.Json.JsonProperty("f", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string F { get; set; } = "json";

        /// <summary>The name of the geodatabase version.</summary>
        [Newtonsoft.Json.JsonProperty("gdbVersion", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GdbVersion { get; set; } = "sde.DEFAULT";

        /// <summary>Optional parameter representing the token (guid) used to lock the version. If the calling client has previously started a service session (editing) and holds an exclusive lock on the specified version, the request will fail if the sessionId is not provided. If the specified version is currently locked by any other session, the request will fail if the sessionId is not provided or does not match the sessionId which holds the exclusive lock.</summary>
        [Newtonsoft.Json.JsonProperty("sessionId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SessionId { get; set; } = "";

        /// <summary>Optional parameter representing the session moment (the default is the version current moment). This should only be specified by the client when they do not want to use the current moment.</summary>
        [Newtonsoft.Json.JsonProperty("moment", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Moment { get; set; }

        /// <summary>The trace type.</summary>
        [Newtonsoft.Json.JsonProperty("traceType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BodyTraceType TraceType { get; set; }

        /// <summary>***Curently a workaround until figure out how to gen**The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.</summary>
        [Newtonsoft.Json.JsonProperty("traceLocations", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<object> TraceLocations { get; set; } = new System.Collections.ObjectModel.Collection<object>();

        /// <summary>The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.</summary>
        [Newtonsoft.Json.JsonProperty("traceConfiguration", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public object TraceConfiguration { get; set; } = new object();

        /// <summary>Optional parameter representing the types of results to return.</summary>
        [Newtonsoft.Json.JsonProperty("resultTypes", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<object> ResultTypes { get; set; } = new System.Collections.ObjectModel.Collection<object>();

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Body2
    {
        [Newtonsoft.Json.JsonProperty("username", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Username { get; set; }

        [Newtonsoft.Json.JsonProperty("password", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Password { get; set; }

        [Newtonsoft.Json.JsonProperty("ip", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Ip { get; set; }

        [Newtonsoft.Json.JsonProperty("referer", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Referer { get; set; }

        [Newtonsoft.Json.JsonProperty("expiration", Required = Newtonsoft.Json.Required.Always)]
        public double Expiration { get; set; }

        [Newtonsoft.Json.JsonProperty("f", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string F { get; set; } = "json";

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Code { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Details { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FunctionBarrierFunctionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"subtract")]
        Subtract = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"average")]
        Average = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"count")]
        Count = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"min")]
        Min = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"max")]
        Max = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FunctionBarrierOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"equal")]
        Equal = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"notEqual")]
        NotEqual = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterThan")]
        GreaterThan = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThan")]
        LessThan = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThanEqual")]
        LessThanEqual = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"includesTheValues")]
        IncludesTheValues = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"doesNotIncludeTheValues")]
        DoesNotIncludeTheValues = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"includesAny")]
        IncludesAny = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"doesNotIncludeAny")]
        DoesNotIncludeAny = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Anonymous
    {
        [Newtonsoft.Json.JsonProperty("functionType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FunctionType FunctionType { get; set; }

        [Newtonsoft.Json.JsonProperty("networkAttributeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string NetworkAttributeName { get; set; }

        [Newtonsoft.Json.JsonProperty("networkAttributeConditions", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<NetworkAttributeConditions> NetworkAttributeConditions { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceLocationType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"startingPoint")]
        StartingPoint = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"stoppingPoint")]
        StoppingPoint = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PropagatorFunctionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"bitwiseAnd")]
        BitwiseAnd = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"min")]
        Min = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"max")]
        Max = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum PropagatorOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"equal")]
        Equal = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"notEqual")]
        NotEqual = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"bitwiseAnd")]
        BitwiseAnd = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"greater")]
        Greater = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterEqual")]
        GreaterEqual = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"less")]
        Less = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"lessEqual")]
        LessEqual = 6,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceConfigurationTraversabilityScope
    {
        [System.Runtime.Serialization.EnumMember(Value = @"junctions")]
        Junctions = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"edges")]
        Edges = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"junctionsAndEdges")]
        JunctionsAndEdges = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TraceOutputConditionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"networkAttribute")]
        NetworkAttribute = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"category")]
        Category = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TraceResults
    {
        [Newtonsoft.Json.JsonProperty("elements", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<Elements> Elements { get; set; }

        [Newtonsoft.Json.JsonProperty("diagramName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string DiagramName { get; set; }

        [Newtonsoft.Json.JsonProperty("globalFunctionResults", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> GlobalFunctionResults { get; set; }

        [Newtonsoft.Json.JsonProperty("kFeaturesForKNNFound", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool KFeaturesForKNNFound { get; set; }

        [Newtonsoft.Json.JsonProperty("startingPointsIgnored", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool StartingPointsIgnored { get; set; }

        [Newtonsoft.Json.JsonProperty("warnings", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Warnings { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error2
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Code { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Details { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Error3
    {
        [Newtonsoft.Json.JsonProperty("code", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double Code { get; set; }

        [Newtonsoft.Json.JsonProperty("message", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Message { get; set; }

        [Newtonsoft.Json.JsonProperty("details", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Details { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BodyTraceType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"upstream")]
        Upstream = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"downstream")]
        Downstream = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"connected")]
        Connected = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"subnetwork")]
        Subnetwork = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"loops")]
        Loops = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"shortestpath")]
        Shortestpath = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"subnetworkcontroller")]
        Subnetworkcontroller = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FunctionType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"add")]
        Add = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"subtract")]
        Subtract = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"average")]
        Average = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"count")]
        Count = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"min")]
        Min = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"max")]
        Max = 5,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class NetworkAttributeConditions
    {
        [Newtonsoft.Json.JsonProperty("networkAttributeName", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string NetworkAttributeName { get; set; }

        [Newtonsoft.Json.JsonProperty("operator", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public NetworkAttributeConditionsOperator Operator { get; set; }

        [Newtonsoft.Json.JsonProperty("value", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Value { get; set; }

        [Newtonsoft.Json.JsonProperty("combineUsingOr", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool CombineUsingOr { get; set; }

        [Newtonsoft.Json.JsonProperty("isTypeSpecificValue", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool IsTypeSpecificValue { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Elements
    {
        [Newtonsoft.Json.JsonProperty("networkSourceId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double NetworkSourceId { get; set; }

        [Newtonsoft.Json.JsonProperty("globalId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string GlobalId { get; set; }

        [Newtonsoft.Json.JsonProperty("objectId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double ObjectId { get; set; }

        [Newtonsoft.Json.JsonProperty("terminalId", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double TerminalId { get; set; }

        [Newtonsoft.Json.JsonProperty("assetGroupCode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double AssetGroupCode { get; set; }

        [Newtonsoft.Json.JsonProperty("assetTypeCode", Required = Newtonsoft.Json.Required.DisallowNull, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double AssetTypeCode { get; set; }

        private System.Collections.Generic.IDictionary<string, object> _additionalProperties = new System.Collections.Generic.Dictionary<string, object>();

        [Newtonsoft.Json.JsonExtensionData]
        public System.Collections.Generic.IDictionary<string, object> AdditionalProperties
        {
            get { return _additionalProperties; }
            set { _additionalProperties = value; }
        }


    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "10.2.1.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum NetworkAttributeConditionsOperator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"equal")]
        Equal = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"notEqual")]
        NotEqual = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterThan")]
        GreaterThan = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"greaterThanEqual")]
        GreaterThanEqual = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThan")]
        LessThan = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"lessThanEqual")]
        LessThanEqual = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"includesTheValues")]
        IncludesTheValues = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"doesNotIncludeTheValues")]
        DoesNotIncludeTheValues = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"includesAny")]
        IncludesAny = 8,

        [System.Runtime.Serialization.EnumMember(Value = @"doesNotIncludeAny")]
        DoesNotIncludeAny = 9,

    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class ApiException<TResult> : ApiException
    {
        public TResult Result { get; private set; }

        public ApiException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore 1591
#pragma warning restore 1573
#pragma warning restore 472
#pragma warning restore 114
#pragma warning restore 108