/**
 * Swagger for Utility Network
 * Open API Specification (OAS/Swagger)  * **trace**, **updateIsConnected** from the [ArcGIS Utility Network]( https://developers.arcgis.com/rest/services-reference/utility-network-service.htm) * **generateToken** from the [ArcGIS REST API](https://developers.arcgis.com/rest/)  Tested on ArcGIS  Enterprise 10.6.1 using [NSwagStudio](https://github.com/RSuter/NSwag/wiki/NSwagStudio) C# code gen . 
 *
 * OpenAPI spec version: 0.13
 * Contact: 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.4.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "TraceConfiguration.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

TraceConfiguration::TraceConfiguration()
{
    m_IncludeContainers = false;
    m_IncludeContainersIsSet = false;
    m_IncludeContent = false;
    m_IncludeContentIsSet = false;
    m_IncludeStructures = false;
    m_IncludeStructuresIsSet = false;
    m_IncludeBarriers = false;
    m_IncludeBarriersIsSet = false;
    m_ValidateConsistency = false;
    m_ValidateConsistencyIsSet = false;
    m_DomainNetworkName = utility::conversions::to_string_t("");
    m_DomainNetworkNameIsSet = false;
    m_TierName = utility::conversions::to_string_t("");
    m_TierNameIsSet = false;
    m_TargetTierName = utility::conversions::to_string_t("");
    m_TargetTierNameIsSet = false;
    m_SubnetworkName = utility::conversions::to_string_t("");
    m_SubnetworkNameIsSet = false;
    m_DiagramTemplateName = utility::conversions::to_string_t("");
    m_DiagramTemplateNameIsSet = false;
    m_ShortestPathNetworkAttributeName = utility::conversions::to_string_t("");
    m_ShortestPathNetworkAttributeNameIsSet = false;
    m_FilterBitsetNetworkAttributeName = utility::conversions::to_string_t("");
    m_FilterBitsetNetworkAttributeNameIsSet = false;
    m_TraversabilityScope = utility::conversions::to_string_t("");
    m_TraversabilityScopeIsSet = false;
    m_CategoryBarriersIsSet = false;
    m_ArcadeExpressionBarrier = utility::conversions::to_string_t("");
    m_ArcadeExpressionBarrierIsSet = false;
    m_FilterScope = utility::conversions::to_string_t("");
    m_FilterScopeIsSet = false;
}

TraceConfiguration::~TraceConfiguration()
{
}

void TraceConfiguration::validate()
{
    // TODO: implement validation
}

web::json::value TraceConfiguration::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m_IncludeContainersIsSet)
    {
        val[utility::conversions::to_string_t("includeContainers")] = ModelBase::toJson(m_IncludeContainers);
    }
    if(m_IncludeContentIsSet)
    {
        val[utility::conversions::to_string_t("includeContent")] = ModelBase::toJson(m_IncludeContent);
    }
    if(m_IncludeStructuresIsSet)
    {
        val[utility::conversions::to_string_t("includeStructures")] = ModelBase::toJson(m_IncludeStructures);
    }
    if(m_IncludeBarriersIsSet)
    {
        val[utility::conversions::to_string_t("includeBarriers")] = ModelBase::toJson(m_IncludeBarriers);
    }
    if(m_ValidateConsistencyIsSet)
    {
        val[utility::conversions::to_string_t("validateConsistency")] = ModelBase::toJson(m_ValidateConsistency);
    }
    if(m_DomainNetworkNameIsSet)
    {
        val[utility::conversions::to_string_t("domainNetworkName")] = ModelBase::toJson(m_DomainNetworkName);
    }
    if(m_TierNameIsSet)
    {
        val[utility::conversions::to_string_t("tierName")] = ModelBase::toJson(m_TierName);
    }
    if(m_TargetTierNameIsSet)
    {
        val[utility::conversions::to_string_t("targetTierName")] = ModelBase::toJson(m_TargetTierName);
    }
    if(m_SubnetworkNameIsSet)
    {
        val[utility::conversions::to_string_t("subnetworkName")] = ModelBase::toJson(m_SubnetworkName);
    }
    if(m_DiagramTemplateNameIsSet)
    {
        val[utility::conversions::to_string_t("diagramTemplateName")] = ModelBase::toJson(m_DiagramTemplateName);
    }
    if(m_ShortestPathNetworkAttributeNameIsSet)
    {
        val[utility::conversions::to_string_t("shortestPathNetworkAttributeName")] = ModelBase::toJson(m_ShortestPathNetworkAttributeName);
    }
    if(m_FilterBitsetNetworkAttributeNameIsSet)
    {
        val[utility::conversions::to_string_t("filterBitsetNetworkAttributeName")] = ModelBase::toJson(m_FilterBitsetNetworkAttributeName);
    }
    if(m_TraversabilityScopeIsSet)
    {
        val[utility::conversions::to_string_t("traversabilityScope")] = ModelBase::toJson(m_TraversabilityScope);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_ConditionBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("conditionBarriers")] = web::json::value::array(jsonArray);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_CategoryBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[utility::conversions::to_string_t("categoryBarriers")] = web::json::value::array(jsonArray);
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_FunctionBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("functionBarriers")] = web::json::value::array(jsonArray);
    }
    if(m_ArcadeExpressionBarrierIsSet)
    {
        val[utility::conversions::to_string_t("arcadeExpressionBarrier")] = ModelBase::toJson(m_ArcadeExpressionBarrier);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_FilterBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("filterBarriers")] = web::json::value::array(jsonArray);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_FilterFunctionBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("filterFunctionBarriers")] = web::json::value::array(jsonArray);
    }
    if(m_FilterScopeIsSet)
    {
        val[utility::conversions::to_string_t("filterScope")] = ModelBase::toJson(m_FilterScope);
    }
    val[utility::conversions::to_string_t("functions")] = ModelBase::toJson(m_Functions);
    val[utility::conversions::to_string_t("nearestNeighbor")] = ModelBase::toJson(m_NearestNeighbor);
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_OutputFilters )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("outputFilters")] = web::json::value::array(jsonArray);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_OutputConditions )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("outputConditions")] = web::json::value::array(jsonArray);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Propagators )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        val[utility::conversions::to_string_t("propagators")] = web::json::value::array(jsonArray);
    }

    return val;
}

void TraceConfiguration::fromJson(web::json::value& val)
{
    if(val.has_field(utility::conversions::to_string_t("includeContainers")))
    {
        setIncludeContainers(ModelBase::boolFromJson(val[utility::conversions::to_string_t("includeContainers")]));
    }
    if(val.has_field(utility::conversions::to_string_t("includeContent")))
    {
        setIncludeContent(ModelBase::boolFromJson(val[utility::conversions::to_string_t("includeContent")]));
    }
    if(val.has_field(utility::conversions::to_string_t("includeStructures")))
    {
        setIncludeStructures(ModelBase::boolFromJson(val[utility::conversions::to_string_t("includeStructures")]));
    }
    if(val.has_field(utility::conversions::to_string_t("includeBarriers")))
    {
        setIncludeBarriers(ModelBase::boolFromJson(val[utility::conversions::to_string_t("includeBarriers")]));
    }
    if(val.has_field(utility::conversions::to_string_t("validateConsistency")))
    {
        setValidateConsistency(ModelBase::boolFromJson(val[utility::conversions::to_string_t("validateConsistency")]));
    }
    if(val.has_field(utility::conversions::to_string_t("domainNetworkName")))
    {
        setDomainNetworkName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("domainNetworkName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("tierName")))
    {
        setTierName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("tierName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("targetTierName")))
    {
        setTargetTierName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("targetTierName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("subnetworkName")))
    {
        setSubnetworkName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("subnetworkName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("diagramTemplateName")))
    {
        setDiagramTemplateName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("diagramTemplateName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("shortestPathNetworkAttributeName")))
    {
        setShortestPathNetworkAttributeName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("shortestPathNetworkAttributeName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("filterBitsetNetworkAttributeName")))
    {
        setFilterBitsetNetworkAttributeName(ModelBase::stringFromJson(val[utility::conversions::to_string_t("filterBitsetNetworkAttributeName")]));
    }
    if(val.has_field(utility::conversions::to_string_t("traversabilityScope")))
    {
        setTraversabilityScope(ModelBase::stringFromJson(val[utility::conversions::to_string_t("traversabilityScope")]));
    }
    {
        m_ConditionBarriers.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("conditionBarriers")].as_array() )
        {
            if(item.is_null())
            {
                m_ConditionBarriers.push_back( std::shared_ptr<ConditionBarrier>(nullptr) );
            }
            else
            {
                std::shared_ptr<ConditionBarrier> newItem(new ConditionBarrier());
                newItem->fromJson(item);
                m_ConditionBarriers.push_back( newItem );
            }
        }
    }
    {
        m_CategoryBarriers.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(utility::conversions::to_string_t("categoryBarriers")))
        {
        for( auto& item : val[utility::conversions::to_string_t("categoryBarriers")].as_array() )
        {
            m_CategoryBarriers.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    {
        m_FunctionBarriers.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("functionBarriers")].as_array() )
        {
            if(item.is_null())
            {
                m_FunctionBarriers.push_back( std::shared_ptr<FunctionBarrier>(nullptr) );
            }
            else
            {
                std::shared_ptr<FunctionBarrier> newItem(new FunctionBarrier());
                newItem->fromJson(item);
                m_FunctionBarriers.push_back( newItem );
            }
        }
    }
    if(val.has_field(utility::conversions::to_string_t("arcadeExpressionBarrier")))
    {
        setArcadeExpressionBarrier(ModelBase::stringFromJson(val[utility::conversions::to_string_t("arcadeExpressionBarrier")]));
    }
    {
        m_FilterBarriers.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("filterBarriers")].as_array() )
        {
            m_FilterBarriers.push_back(ModelBase::stringFromJson(item));
        }
    }
    {
        m_FilterFunctionBarriers.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("filterFunctionBarriers")].as_array() )
        {
            m_FilterFunctionBarriers.push_back(ModelBase::stringFromJson(item));
        }
    }
    if(val.has_field(utility::conversions::to_string_t("filterScope")))
    {
        setFilterScope(ModelBase::stringFromJson(val[utility::conversions::to_string_t("filterScope")]));
    }
    std::shared_ptr<Object> newFunctions(nullptr);
    newFunctions->fromJson(val[utility::conversions::to_string_t("functions")]);
    setFunctions( newFunctions );
    std::shared_ptr<NearestNeighborParam> newNearestNeighbor(new NearestNeighborParam());
    newNearestNeighbor->fromJson(val[utility::conversions::to_string_t("nearestNeighbor")]);
    setNearestNeighbor( newNearestNeighbor );
    {
        m_OutputFilters.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("outputFilters")].as_array() )
        {
            if(item.is_null())
            {
                m_OutputFilters.push_back( std::shared_ptr<TraceOutputCondition>(nullptr) );
            }
            else
            {
                std::shared_ptr<TraceOutputCondition> newItem(new TraceOutputCondition());
                newItem->fromJson(item);
                m_OutputFilters.push_back( newItem );
            }
        }
    }
    {
        m_OutputConditions.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("outputConditions")].as_array() )
        {
            if(item.is_null())
            {
                m_OutputConditions.push_back( std::shared_ptr<OutputFilter>(nullptr) );
            }
            else
            {
                std::shared_ptr<OutputFilter> newItem(new OutputFilter());
                newItem->fromJson(item);
                m_OutputConditions.push_back( newItem );
            }
        }
    }
    {
        m_Propagators.clear();
        std::vector<web::json::value> jsonArray;
        for( auto& item : val[utility::conversions::to_string_t("propagators")].as_array() )
        {
            if(item.is_null())
            {
                m_Propagators.push_back( std::shared_ptr<Propagator>(nullptr) );
            }
            else
            {
                std::shared_ptr<Propagator> newItem(new Propagator());
                newItem->fromJson(item);
                m_Propagators.push_back( newItem );
            }
        }
    }
}

void TraceConfiguration::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(m_IncludeContainersIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("includeContainers"), m_IncludeContainers));
    }
    if(m_IncludeContentIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("includeContent"), m_IncludeContent));
    }
    if(m_IncludeStructuresIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("includeStructures"), m_IncludeStructures));
    }
    if(m_IncludeBarriersIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("includeBarriers"), m_IncludeBarriers));
    }
    if(m_ValidateConsistencyIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("validateConsistency"), m_ValidateConsistency));
    }
    if(m_DomainNetworkNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("domainNetworkName"), m_DomainNetworkName));
        
    }
    if(m_TierNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("tierName"), m_TierName));
        
    }
    if(m_TargetTierNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("targetTierName"), m_TargetTierName));
        
    }
    if(m_SubnetworkNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("subnetworkName"), m_SubnetworkName));
        
    }
    if(m_DiagramTemplateNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("diagramTemplateName"), m_DiagramTemplateName));
        
    }
    if(m_ShortestPathNetworkAttributeNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("shortestPathNetworkAttributeName"), m_ShortestPathNetworkAttributeName));
        
    }
    if(m_FilterBitsetNetworkAttributeNameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("filterBitsetNetworkAttributeName"), m_FilterBitsetNetworkAttributeName));
        
    }
    if(m_TraversabilityScopeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("traversabilityScope"), m_TraversabilityScope));
        
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_ConditionBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("conditionBarriers"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_CategoryBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("categoryBarriers"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
        }
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_FunctionBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("functionBarriers"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
    if(m_ArcadeExpressionBarrierIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("arcadeExpressionBarrier"), m_ArcadeExpressionBarrier));
        
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_FilterBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("filterBarriers"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_FilterFunctionBarriers )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("filterFunctionBarriers"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
    if(m_FilterScopeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("filterScope"), m_FilterScope));
        
    }
    m_Functions->toMultipart(multipart, utility::conversions::to_string_t("functions."));
    m_NearestNeighbor->toMultipart(multipart, utility::conversions::to_string_t("nearestNeighbor."));
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_OutputFilters )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("outputFilters"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_OutputConditions )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("outputConditions"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Propagators )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t("propagators"), web::json::value::array(jsonArray), utility::conversions::to_string_t("application/json")));
            }
}

void TraceConfiguration::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t("."))
    {
        namePrefix += utility::conversions::to_string_t(".");
    }

    if(multipart->hasContent(utility::conversions::to_string_t("includeContainers")))
    {
        setIncludeContainers(ModelBase::boolFromHttpContent(multipart->getContent(utility::conversions::to_string_t("includeContainers"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("includeContent")))
    {
        setIncludeContent(ModelBase::boolFromHttpContent(multipart->getContent(utility::conversions::to_string_t("includeContent"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("includeStructures")))
    {
        setIncludeStructures(ModelBase::boolFromHttpContent(multipart->getContent(utility::conversions::to_string_t("includeStructures"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("includeBarriers")))
    {
        setIncludeBarriers(ModelBase::boolFromHttpContent(multipart->getContent(utility::conversions::to_string_t("includeBarriers"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("validateConsistency")))
    {
        setValidateConsistency(ModelBase::boolFromHttpContent(multipart->getContent(utility::conversions::to_string_t("validateConsistency"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("domainNetworkName")))
    {
        setDomainNetworkName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("domainNetworkName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("tierName")))
    {
        setTierName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("tierName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("targetTierName")))
    {
        setTargetTierName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("targetTierName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("subnetworkName")))
    {
        setSubnetworkName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("subnetworkName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("diagramTemplateName")))
    {
        setDiagramTemplateName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("diagramTemplateName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("shortestPathNetworkAttributeName")))
    {
        setShortestPathNetworkAttributeName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("shortestPathNetworkAttributeName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("filterBitsetNetworkAttributeName")))
    {
        setFilterBitsetNetworkAttributeName(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("filterBitsetNetworkAttributeName"))));
    }
    if(multipart->hasContent(utility::conversions::to_string_t("traversabilityScope")))
    {
        setTraversabilityScope(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("traversabilityScope"))));
    }
    {
        m_ConditionBarriers.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("conditionBarriers"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_ConditionBarriers.push_back( std::shared_ptr<ConditionBarrier>(nullptr) );
            }
            else
            {
                std::shared_ptr<ConditionBarrier> newItem(new ConditionBarrier());
                newItem->fromJson(item);
                m_ConditionBarriers.push_back( newItem );
            }
        }
    }
    {
        m_CategoryBarriers.clear();
        if(multipart->hasContent(utility::conversions::to_string_t("categoryBarriers")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("categoryBarriers"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_CategoryBarriers.push_back(ModelBase::stringFromJson(item));
        }
        }
    }
    {
        m_FunctionBarriers.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("functionBarriers"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_FunctionBarriers.push_back( std::shared_ptr<FunctionBarrier>(nullptr) );
            }
            else
            {
                std::shared_ptr<FunctionBarrier> newItem(new FunctionBarrier());
                newItem->fromJson(item);
                m_FunctionBarriers.push_back( newItem );
            }
        }
    }
    if(multipart->hasContent(utility::conversions::to_string_t("arcadeExpressionBarrier")))
    {
        setArcadeExpressionBarrier(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("arcadeExpressionBarrier"))));
    }
    {
        m_FilterBarriers.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("filterBarriers"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_FilterBarriers.push_back(ModelBase::stringFromJson(item));
        }
    }
    {
        m_FilterFunctionBarriers.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("filterFunctionBarriers"))));
        for( auto& item : jsonArray.as_array() )
        {
            m_FilterFunctionBarriers.push_back(ModelBase::stringFromJson(item));
        }
    }
    if(multipart->hasContent(utility::conversions::to_string_t("filterScope")))
    {
        setFilterScope(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("filterScope"))));
    }
    std::shared_ptr<Object> newFunctions(nullptr);
    newFunctions->fromMultiPart(multipart, utility::conversions::to_string_t("functions."));
    setFunctions( newFunctions );
    std::shared_ptr<NearestNeighborParam> newNearestNeighbor(new NearestNeighborParam());
    newNearestNeighbor->fromMultiPart(multipart, utility::conversions::to_string_t("nearestNeighbor."));
    setNearestNeighbor( newNearestNeighbor );
    {
        m_OutputFilters.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("outputFilters"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_OutputFilters.push_back( std::shared_ptr<TraceOutputCondition>(nullptr) );
            }
            else
            {
                std::shared_ptr<TraceOutputCondition> newItem(new TraceOutputCondition());
                newItem->fromJson(item);
                m_OutputFilters.push_back( newItem );
            }
        }
    }
    {
        m_OutputConditions.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("outputConditions"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_OutputConditions.push_back( std::shared_ptr<OutputFilter>(nullptr) );
            }
            else
            {
                std::shared_ptr<OutputFilter> newItem(new OutputFilter());
                newItem->fromJson(item);
                m_OutputConditions.push_back( newItem );
            }
        }
    }
    {
        m_Propagators.clear();

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(utility::conversions::to_string_t("propagators"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_Propagators.push_back( std::shared_ptr<Propagator>(nullptr) );
            }
            else
            {
                std::shared_ptr<Propagator> newItem(new Propagator());
                newItem->fromJson(item);
                m_Propagators.push_back( newItem );
            }
        }
    }
}

bool TraceConfiguration::isIncludeContainers() const
{
    return m_IncludeContainers;
}


void TraceConfiguration::setIncludeContainers(bool value)
{
    m_IncludeContainers = value;
    m_IncludeContainersIsSet = true;
}
bool TraceConfiguration::includeContainersIsSet() const
{
    return m_IncludeContainersIsSet;
}

void TraceConfiguration::unsetIncludeContainers()
{
    m_IncludeContainersIsSet = false;
}

bool TraceConfiguration::isIncludeContent() const
{
    return m_IncludeContent;
}


void TraceConfiguration::setIncludeContent(bool value)
{
    m_IncludeContent = value;
    m_IncludeContentIsSet = true;
}
bool TraceConfiguration::includeContentIsSet() const
{
    return m_IncludeContentIsSet;
}

void TraceConfiguration::unsetIncludeContent()
{
    m_IncludeContentIsSet = false;
}

bool TraceConfiguration::isIncludeStructures() const
{
    return m_IncludeStructures;
}


void TraceConfiguration::setIncludeStructures(bool value)
{
    m_IncludeStructures = value;
    m_IncludeStructuresIsSet = true;
}
bool TraceConfiguration::includeStructuresIsSet() const
{
    return m_IncludeStructuresIsSet;
}

void TraceConfiguration::unsetIncludeStructures()
{
    m_IncludeStructuresIsSet = false;
}

bool TraceConfiguration::isIncludeBarriers() const
{
    return m_IncludeBarriers;
}


void TraceConfiguration::setIncludeBarriers(bool value)
{
    m_IncludeBarriers = value;
    m_IncludeBarriersIsSet = true;
}
bool TraceConfiguration::includeBarriersIsSet() const
{
    return m_IncludeBarriersIsSet;
}

void TraceConfiguration::unsetIncludeBarriers()
{
    m_IncludeBarriersIsSet = false;
}

bool TraceConfiguration::isValidateConsistency() const
{
    return m_ValidateConsistency;
}


void TraceConfiguration::setValidateConsistency(bool value)
{
    m_ValidateConsistency = value;
    m_ValidateConsistencyIsSet = true;
}
bool TraceConfiguration::validateConsistencyIsSet() const
{
    return m_ValidateConsistencyIsSet;
}

void TraceConfiguration::unsetValidateConsistency()
{
    m_ValidateConsistencyIsSet = false;
}

utility::string_t TraceConfiguration::getDomainNetworkName() const
{
    return m_DomainNetworkName;
}


void TraceConfiguration::setDomainNetworkName(utility::string_t value)
{
    m_DomainNetworkName = value;
    m_DomainNetworkNameIsSet = true;
}
bool TraceConfiguration::domainNetworkNameIsSet() const
{
    return m_DomainNetworkNameIsSet;
}

void TraceConfiguration::unsetDomainNetworkName()
{
    m_DomainNetworkNameIsSet = false;
}

utility::string_t TraceConfiguration::getTierName() const
{
    return m_TierName;
}


void TraceConfiguration::setTierName(utility::string_t value)
{
    m_TierName = value;
    m_TierNameIsSet = true;
}
bool TraceConfiguration::tierNameIsSet() const
{
    return m_TierNameIsSet;
}

void TraceConfiguration::unsetTierName()
{
    m_TierNameIsSet = false;
}

utility::string_t TraceConfiguration::getTargetTierName() const
{
    return m_TargetTierName;
}


void TraceConfiguration::setTargetTierName(utility::string_t value)
{
    m_TargetTierName = value;
    m_TargetTierNameIsSet = true;
}
bool TraceConfiguration::targetTierNameIsSet() const
{
    return m_TargetTierNameIsSet;
}

void TraceConfiguration::unsetTargetTierName()
{
    m_TargetTierNameIsSet = false;
}

utility::string_t TraceConfiguration::getSubnetworkName() const
{
    return m_SubnetworkName;
}


void TraceConfiguration::setSubnetworkName(utility::string_t value)
{
    m_SubnetworkName = value;
    m_SubnetworkNameIsSet = true;
}
bool TraceConfiguration::subnetworkNameIsSet() const
{
    return m_SubnetworkNameIsSet;
}

void TraceConfiguration::unsetSubnetworkName()
{
    m_SubnetworkNameIsSet = false;
}

utility::string_t TraceConfiguration::getDiagramTemplateName() const
{
    return m_DiagramTemplateName;
}


void TraceConfiguration::setDiagramTemplateName(utility::string_t value)
{
    m_DiagramTemplateName = value;
    m_DiagramTemplateNameIsSet = true;
}
bool TraceConfiguration::diagramTemplateNameIsSet() const
{
    return m_DiagramTemplateNameIsSet;
}

void TraceConfiguration::unsetDiagramTemplateName()
{
    m_DiagramTemplateNameIsSet = false;
}

utility::string_t TraceConfiguration::getShortestPathNetworkAttributeName() const
{
    return m_ShortestPathNetworkAttributeName;
}


void TraceConfiguration::setShortestPathNetworkAttributeName(utility::string_t value)
{
    m_ShortestPathNetworkAttributeName = value;
    m_ShortestPathNetworkAttributeNameIsSet = true;
}
bool TraceConfiguration::shortestPathNetworkAttributeNameIsSet() const
{
    return m_ShortestPathNetworkAttributeNameIsSet;
}

void TraceConfiguration::unsetShortestPathNetworkAttributeName()
{
    m_ShortestPathNetworkAttributeNameIsSet = false;
}

utility::string_t TraceConfiguration::getFilterBitsetNetworkAttributeName() const
{
    return m_FilterBitsetNetworkAttributeName;
}


void TraceConfiguration::setFilterBitsetNetworkAttributeName(utility::string_t value)
{
    m_FilterBitsetNetworkAttributeName = value;
    m_FilterBitsetNetworkAttributeNameIsSet = true;
}
bool TraceConfiguration::filterBitsetNetworkAttributeNameIsSet() const
{
    return m_FilterBitsetNetworkAttributeNameIsSet;
}

void TraceConfiguration::unsetFilterBitsetNetworkAttributeName()
{
    m_FilterBitsetNetworkAttributeNameIsSet = false;
}

utility::string_t TraceConfiguration::getTraversabilityScope() const
{
    return m_TraversabilityScope;
}


void TraceConfiguration::setTraversabilityScope(utility::string_t value)
{
    m_TraversabilityScope = value;
    m_TraversabilityScopeIsSet = true;
}
bool TraceConfiguration::traversabilityScopeIsSet() const
{
    return m_TraversabilityScopeIsSet;
}

void TraceConfiguration::unsetTraversabilityScope()
{
    m_TraversabilityScopeIsSet = false;
}

std::vector<std::shared_ptr<ConditionBarrier>>& TraceConfiguration::getConditionBarriers()
{
    return m_ConditionBarriers;
}

void TraceConfiguration::setConditionBarriers(std::vector<std::shared_ptr<ConditionBarrier>> value)
{
    m_ConditionBarriers = value;
    
}
std::vector<utility::string_t>& TraceConfiguration::getCategoryBarriers()
{
    return m_CategoryBarriers;
}

void TraceConfiguration::setCategoryBarriers(std::vector<utility::string_t> value)
{
    m_CategoryBarriers = value;
    m_CategoryBarriersIsSet = true;
}
bool TraceConfiguration::categoryBarriersIsSet() const
{
    return m_CategoryBarriersIsSet;
}

void TraceConfiguration::unsetCategoryBarriers()
{
    m_CategoryBarriersIsSet = false;
}

std::vector<std::shared_ptr<FunctionBarrier>>& TraceConfiguration::getFunctionBarriers()
{
    return m_FunctionBarriers;
}

void TraceConfiguration::setFunctionBarriers(std::vector<std::shared_ptr<FunctionBarrier>> value)
{
    m_FunctionBarriers = value;
    
}
utility::string_t TraceConfiguration::getArcadeExpressionBarrier() const
{
    return m_ArcadeExpressionBarrier;
}


void TraceConfiguration::setArcadeExpressionBarrier(utility::string_t value)
{
    m_ArcadeExpressionBarrier = value;
    m_ArcadeExpressionBarrierIsSet = true;
}
bool TraceConfiguration::arcadeExpressionBarrierIsSet() const
{
    return m_ArcadeExpressionBarrierIsSet;
}

void TraceConfiguration::unsetArcadeExpressionBarrier()
{
    m_ArcadeExpressionBarrierIsSet = false;
}

std::vector<utility::string_t>& TraceConfiguration::getFilterBarriers()
{
    return m_FilterBarriers;
}

void TraceConfiguration::setFilterBarriers(std::vector<utility::string_t> value)
{
    m_FilterBarriers = value;
    
}
std::vector<utility::string_t>& TraceConfiguration::getFilterFunctionBarriers()
{
    return m_FilterFunctionBarriers;
}

void TraceConfiguration::setFilterFunctionBarriers(std::vector<utility::string_t> value)
{
    m_FilterFunctionBarriers = value;
    
}
utility::string_t TraceConfiguration::getFilterScope() const
{
    return m_FilterScope;
}


void TraceConfiguration::setFilterScope(utility::string_t value)
{
    m_FilterScope = value;
    m_FilterScopeIsSet = true;
}
bool TraceConfiguration::filterScopeIsSet() const
{
    return m_FilterScopeIsSet;
}

void TraceConfiguration::unsetFilterScope()
{
    m_FilterScopeIsSet = false;
}

std::shared_ptr<Object> TraceConfiguration::getFunctions() const
{
    return m_Functions;
}


void TraceConfiguration::setFunctions(std::shared_ptr<Object> value)
{
    m_Functions = value;
    
}
std::shared_ptr<NearestNeighborParam> TraceConfiguration::getNearestNeighbor() const
{
    return m_NearestNeighbor;
}


void TraceConfiguration::setNearestNeighbor(std::shared_ptr<NearestNeighborParam> value)
{
    m_NearestNeighbor = value;
    
}
std::vector<std::shared_ptr<TraceOutputCondition>>& TraceConfiguration::getOutputFilters()
{
    return m_OutputFilters;
}

void TraceConfiguration::setOutputFilters(std::vector<std::shared_ptr<TraceOutputCondition>> value)
{
    m_OutputFilters = value;
    
}
std::vector<std::shared_ptr<OutputFilter>>& TraceConfiguration::getOutputConditions()
{
    return m_OutputConditions;
}

void TraceConfiguration::setOutputConditions(std::vector<std::shared_ptr<OutputFilter>> value)
{
    m_OutputConditions = value;
    
}
std::vector<std::shared_ptr<Propagator>>& TraceConfiguration::getPropagators()
{
    return m_Propagators;
}

void TraceConfiguration::setPropagators(std::vector<std::shared_ptr<Propagator>> value)
{
    m_Propagators = value;
    
}
}
}
}
}

