/**
 * Swagger for Utility Network
 * Open API Specification (OAS/Swagger)  * **trace**, **updateIsConnected** from the [ArcGIS Utility Network]( https://developers.arcgis.com/rest/services-reference/utility-network-service.htm) * **generateToken** from the [ArcGIS REST API](https://developers.arcgis.com/rest/)  Tested on ArcGIS  Enterprise 10.6.1 using [NSwagStudio](https://github.com/RSuter/NSwag/wiki/NSwagStudio) C# code gen . 
 *
 * OpenAPI spec version: 0.13
 * Contact: 
 *
 * NOTE: This class is auto generated by the swagger code generator 2.4.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


#include "UtilityNetworkServiceApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace io {
namespace swagger {
namespace client {
namespace api {

using namespace io::swagger::client::model;

UtilityNetworkServiceApi::UtilityNetworkServiceApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

UtilityNetworkServiceApi::~UtilityNetworkServiceApi()
{
}

pplx::task<std::shared_ptr<TokenResponse>> UtilityNetworkServiceApi::portalWebAdaptorSharingRestGenerateTokenPost(utility::string_t portalWebAdaptor, utility::string_t username, utility::string_t password, double expiration, utility::string_t f, boost::optional<utility::string_t> ip, boost::optional<utility::string_t> referer)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{PortalWebAdaptor}/sharing/rest/generateToken");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("PortalWebAdaptor") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(portalWebAdaptor));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("UtilityNetworkServiceApi->portalWebAdaptorSharingRestGenerateTokenPost does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    {
        formParams[ utility::conversions::to_string_t("username") ] = ApiClient::parameterToString(username);
    }
    {
        formParams[ utility::conversions::to_string_t("password") ] = ApiClient::parameterToString(password);
    }
    {
        formParams[ utility::conversions::to_string_t("expiration") ] = ApiClient::parameterToString(expiration);
    }
    {
        formParams[ utility::conversions::to_string_t("f") ] = ApiClient::parameterToString(f);
    }
    if (ip)
    {
        formParams[ utility::conversions::to_string_t("ip") ] = ApiClient::parameterToString(*ip);
    }
    if (referer)
    {
        formParams[ utility::conversions::to_string_t("referer") ] = ApiClient::parameterToString(*referer);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("UtilityNetworkServiceApi->portalWebAdaptorSharingRestGenerateTokenPost does not consume any supported media type"));
    }


    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling portalWebAdaptorSharingRestGenerateTokenPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling portalWebAdaptorSharingRestGenerateTokenPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<TokenResponse> result(new TokenResponse());

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling portalWebAdaptorSharingRestGenerateTokenPost: unsupported response type"));
        }

        return result;
    });
}
pplx::task<std::shared_ptr<TraceResultsSet>> UtilityNetworkServiceApi::trace(utility::string_t serverWebAdaptor, utility::string_t utilityNetworkName, utility::string_t token, utility::string_t f, utility::string_t traceType, utility::string_t traceLocations, utility::string_t traceConfiguration, boost::optional<utility::string_t> gdbVersion, boost::optional<utility::string_t> sessionId, boost::optional<utility::string_t> moment)
{


    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = utility::conversions::to_string_t("/{ServerWebAdaptor}/rest/services/{UtilityNetworkName}/UtilityNetworkServer/trace");
    boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("ServerWebAdaptor") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(serverWebAdaptor));
boost::replace_all(path, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("UtilityNetworkName") + utility::conversions::to_string_t("}"), ApiClient::parameterToString(utilityNetworkName));

    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    utility::string_t responseHttpContentType;

    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( responseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( responseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("UtilityNetworkServiceApi->trace does not produce any supported media type"));
    }

    headerParams[utility::conversions::to_string_t("Accept")] = responseHttpContentType;

    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    {
        queryParams[utility::conversions::to_string_t("token")] = ApiClient::parameterToString(token);
    }
    {
        formParams[ utility::conversions::to_string_t("f") ] = ApiClient::parameterToString(f);
    }
    {
        formParams[ utility::conversions::to_string_t("traceType") ] = ApiClient::parameterToString(traceType);
    }
    {
        formParams[ utility::conversions::to_string_t("traceLocations") ] = ApiClient::parameterToString(traceLocations);
    }
    {
        formParams[ utility::conversions::to_string_t("traceConfiguration") ] = ApiClient::parameterToString(traceConfiguration);
    }
    if (gdbVersion)
    {
        formParams[ utility::conversions::to_string_t("gdbVersion") ] = ApiClient::parameterToString(*gdbVersion);
    }
    if (sessionId)
    {
        formParams[ utility::conversions::to_string_t("sessionId") ] = ApiClient::parameterToString(*sessionId);
    }
    if (moment)
    {
        formParams[ utility::conversions::to_string_t("moment") ] = ApiClient::parameterToString(*moment);
    }

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;

    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( consumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("UtilityNetworkServiceApi->trace does not consume any supported media type"));
    }


    return m_ApiClient->callApi(path, utility::conversions::to_string_t("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , utility::conversions::to_string_t("error calling trace: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }

        // check response content type
        if(response.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t contentType = response.headers()[utility::conversions::to_string_t("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling trace: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }

        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<TraceResultsSet> result(new TraceResultsSet());

        if(responseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value json = web::json::value::parse(response);

            result->fromJson(json);
        }
        // else if(responseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling trace: unsupported response type"));
        }

        return result;
    });
}

}
}
}
}

