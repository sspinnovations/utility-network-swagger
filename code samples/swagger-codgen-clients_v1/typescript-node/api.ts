/**
 * Swagger for Utility Network
 * Open API Specification (OAS/Swagger)  * **trace**, **updateIsConnected** from the [ArcGIS Utility Network]( https://developers.arcgis.com/rest/services-reference/utility-network-service.htm) * **generateToken** from the [ArcGIS REST API](https://developers.arcgis.com/rest/)  Tested on ArcGIS  Enterprise 10.6.1 using [NSwagStudio](https://github.com/RSuter/NSwag/wiki/NSwagStudio) C# code gen . 
 *
 * OpenAPI spec version: 0.13
 * Contact: 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://t4e7j4g.restletmocks.net';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class ConditionBarrier {
    'networkAttributeName': string;
    'operator': string;
    /**
    * 0 = unknown, 1 = open, 2 = closed
    */
    'value': number;
    'combineUsingOr': boolean;
    'isTypeSpecificValue': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkAttributeName",
            "baseName": "networkAttributeName",
            "type": "string"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "combineUsingOr",
            "baseName": "combineUsingOr",
            "type": "boolean"
        },
        {
            "name": "isTypeSpecificValue",
            "baseName": "isTypeSpecificValue",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ConditionBarrier.attributeTypeMap;
    }
}

export class Feature {
    /**
    * networkSourceId
    */
    'networkSourceId'?: string;
    /**
    * guid
    */
    'globalId'?: string;
    /**
    * objectId
    */
    'objectId'?: number;
    /**
    * terminalId
    */
    'terminalId'?: number;
    'networkAttributes'?: Array<number>;
    /**
    * assetGroup
    */
    'assetGroup'?: number;
    /**
    * assetType
    */
    'assetType'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkSourceId",
            "baseName": "networkSourceId",
            "type": "string"
        },
        {
            "name": "globalId",
            "baseName": "globalId",
            "type": "string"
        },
        {
            "name": "objectId",
            "baseName": "objectId",
            "type": "number"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "number"
        },
        {
            "name": "networkAttributes",
            "baseName": "networkAttributes",
            "type": "Array<number>"
        },
        {
            "name": "assetGroup",
            "baseName": "assetGroup",
            "type": "number"
        },
        {
            "name": "assetType",
            "baseName": "assetType",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Feature.attributeTypeMap;
    }
}

/**
* Array of objects; optional parameter.
*/
export class FunctionBarrier {
    /**
    * Choose from a number of different calculation functions.
    */
    'functionType': FunctionBarrier.FunctionTypeEnum;
    /**
    * Choose to filter by any network attribute defined in the system.
    */
    'networkAttributeName': string;
    /**
    * Choose from a number of different operators
    */
    'operator': FunctionBarrier.OperatorEnum;
    /**
    * Specific value of the input attribute type that, if discovered, will cause the termination.(string (numeric)
    */
    'value': string;
    /**
    * Calculates values in each direction as opposed to an overall global value.
    */
    'useLocalValues'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "functionType",
            "baseName": "functionType",
            "type": "FunctionBarrier.FunctionTypeEnum"
        },
        {
            "name": "networkAttributeName",
            "baseName": "networkAttributeName",
            "type": "string"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "FunctionBarrier.OperatorEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "useLocalValues",
            "baseName": "useLocalValues",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FunctionBarrier.attributeTypeMap;
    }
}

export namespace FunctionBarrier {
    export enum FunctionTypeEnum {
        Add = <any> 'add',
        Subtract = <any> 'subtract',
        Average = <any> 'average',
        Count = <any> 'count',
        Min = <any> 'min',
        Max = <any> 'max'
    }
    export enum OperatorEnum {
        Equal = <any> 'equal',
        NotEqual = <any> 'notEqual',
        GreaterThan = <any> 'greaterThan',
        LessThan = <any> 'lessThan',
        LessThanEqual = <any> 'lessThanEqual',
        IncludesTheValues = <any> 'includesTheValues',
        DoesNotIncludeTheValues = <any> 'doesNotIncludeTheValues',
        IncludesAny = <any> 'includesAny',
        DoesNotIncludeAny = <any> 'doesNotIncludeAny'
    }
}
export class Functions extends Array<FunctionsInner> {

    static discriminator: string | undefined = undefined;

}

export class FunctionsInner {
    'functionType': FunctionsInner.FunctionTypeEnum;
    'networkAttributeName': string;
    'networkAttributeConditions'?: Array<FunctionsInnerNetworkAttributeConditions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "functionType",
            "baseName": "functionType",
            "type": "FunctionsInner.FunctionTypeEnum"
        },
        {
            "name": "networkAttributeName",
            "baseName": "networkAttributeName",
            "type": "string"
        },
        {
            "name": "networkAttributeConditions",
            "baseName": "networkAttributeConditions",
            "type": "Array<FunctionsInnerNetworkAttributeConditions>"
        }    ];

    static getAttributeTypeMap() {
        return FunctionsInner.attributeTypeMap;
    }
}

export namespace FunctionsInner {
    export enum FunctionTypeEnum {
        Add = <any> 'add',
        Subtract = <any> 'subtract',
        Average = <any> 'average',
        Count = <any> 'count',
        Min = <any> 'min',
        Max = <any> 'max'
    }
}
export class FunctionsInnerNetworkAttributeConditions {
    'networkAttributeName'?: string;
    'operator'?: FunctionsInnerNetworkAttributeConditions.OperatorEnum;
    'value'?: string;
    'combineUsingOr'?: boolean;
    'isTypeSpecificValue'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkAttributeName",
            "baseName": "networkAttributeName",
            "type": "string"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "FunctionsInnerNetworkAttributeConditions.OperatorEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "combineUsingOr",
            "baseName": "combineUsingOr",
            "type": "boolean"
        },
        {
            "name": "isTypeSpecificValue",
            "baseName": "isTypeSpecificValue",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return FunctionsInnerNetworkAttributeConditions.attributeTypeMap;
    }
}

export namespace FunctionsInnerNetworkAttributeConditions {
    export enum OperatorEnum {
        Equal = <any> 'equal',
        NotEqual = <any> 'notEqual',
        GreaterThan = <any> 'greaterThan',
        GreaterThanEqual = <any> 'greaterThanEqual',
        LessThan = <any> 'lessThan',
        LessThanEqual = <any> 'lessThanEqual',
        IncludesTheValues = <any> 'includesTheValues',
        DoesNotIncludeTheValues = <any> 'doesNotIncludeTheValues',
        IncludesAny = <any> 'includesAny',
        DoesNotIncludeAny = <any> 'doesNotIncludeAny'
    }
}
export class NearestNeighborParam {
    'count'?: number;
    'costNetworkAttributeName'?: string;
    'nearestCategories': Array<string>;
    'nearestAssets': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "costNetworkAttributeName",
            "baseName": "costNetworkAttributeName",
            "type": "string"
        },
        {
            "name": "nearestCategories",
            "baseName": "nearestCategories",
            "type": "Array<string>"
        },
        {
            "name": "nearestAssets",
            "baseName": "nearestAssets",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NearestNeighborParam.attributeTypeMap;
    }
}

export class NetworkAttribute {
    'networkAttribute'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkAttribute",
            "baseName": "networkAttribute",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return NetworkAttribute.attributeTypeMap;
    }
}

export class OutputFilter {
    'sourceId': number;
    'assetGroup': number;
    'assetType': number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceId",
            "baseName": "sourceId",
            "type": "number"
        },
        {
            "name": "assetGroup",
            "baseName": "assetGroup",
            "type": "number"
        },
        {
            "name": "assetType",
            "baseName": "assetType",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return OutputFilter.attributeTypeMap;
    }
}

export class Propagator {
    'networkAttributeName': string;
    'functionType': Propagator.FunctionTypeEnum;
    'operator': Propagator.OperatorEnum;
    /**
    * string (numeric)
    */
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkAttributeName",
            "baseName": "networkAttributeName",
            "type": "string"
        },
        {
            "name": "functionType",
            "baseName": "functionType",
            "type": "Propagator.FunctionTypeEnum"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "Propagator.OperatorEnum"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Propagator.attributeTypeMap;
    }
}

export namespace Propagator {
    export enum FunctionTypeEnum {
        BitwiseAnd = <any> 'bitwiseAnd',
        Min = <any> 'min',
        Max = <any> 'max'
    }
    export enum OperatorEnum {
        Equal = <any> 'equal',
        NotEqual = <any> 'notEqual',
        BitwiseAnd = <any> 'bitwiseAnd',
        Greater = <any> 'greater',
        GreaterEqual = <any> 'greaterEqual',
        Less = <any> 'less',
        LessEqual = <any> 'lessEqual'
    }
}
export class TokenRequest {
    'username': string;
    'password': string;
    'ip'?: string;
    'referer'?: string;
    'expiration': number;
    'f': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "ip",
            "baseName": "ip",
            "type": "string"
        },
        {
            "name": "referer",
            "baseName": "referer",
            "type": "string"
        },
        {
            "name": "expiration",
            "baseName": "expiration",
            "type": "number"
        },
        {
            "name": "f",
            "baseName": "f",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TokenRequest.attributeTypeMap;
    }
}

/**
* Token reesponse from Portal
*/
export class TokenResponse {
    /**
    * The generated token.
    */
    'token'?: string;
    /**
    * The expiration time of the token in milliseconds since Jan. 1, 1970 (UTC).
    */
    'expires'?: number;
    /**
    * True if the token must always pass over ssl.
    */
    'ssl'?: boolean;
    'error'?: TokenResponseError;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "expires",
            "baseName": "expires",
            "type": "number"
        },
        {
            "name": "ssl",
            "baseName": "ssl",
            "type": "boolean"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "TokenResponseError"
        }    ];

    static getAttributeTypeMap() {
        return TokenResponse.attributeTypeMap;
    }
}

export class TokenResponseError {
    'code'?: number;
    'message'?: string;
    'details'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "number"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TokenResponseError.attributeTypeMap;
    }
}

export class TraceConfiguration {
    /**
    * Optional parameter representing whether or not to include containers in the trace result (default is false).
    */
    'includeContainers'?: boolean;
    /**
    * Optional parameter representing whether or not to include content in the trace result (default is false).
    */
    'includeContent'?: boolean;
    /**
    * Optional parameter representing whether or not to include structures in the trace result (default is false).
    */
    'includeStructures'?: boolean;
    /**
    * Optional parameter representing whether or not to include barrier features that stop a trace in the trace result (default is true).
    */
    'includeBarriers'?: boolean;
    /**
    * Optional parameter representing whether or not to validate the consistency of the trace results (default is false).
    */
    'validateConsistency'?: boolean;
    /**
    * Optional parameter that specifies the name of the domain network where the trace is starting.
    */
    'domainNetworkName'?: string;
    /**
    * Optional parameter that specifies the name of the tier where the trace is starting.
    */
    'tierName'?: string;
    /**
    * Optional parameter representing the name of the tier where upstream or downstream trace ends.
    */
    'targetTierName'?: string;
    /**
    * Optional parameter representing the name of the subnetwork that will be traced - the starting points of the trace will be the controllers of this subnetwork .
    */
    'subnetworkName'?: string;
    /**
    * Optional parameter representing the name of the diagram template.
    */
    'diagramTemplateName'?: string;
    /**
    * Required parameter for shortest path trace ; optional otherwise. It represents the network attribute name used for determining cost when calulating the shortest path.
    */
    'shortestPathNetworkAttributeName'?: string;
    /**
    * Optional parameter. Used during loops trace to only return loops with the same bit set all around the loop. Used during upstream/downstream traces to ensure that trace results include any bit that is set in the starting points for the network attribute.
    */
    'filterBitsetNetworkAttributeName'?: string;
    /**
    * Optional parameters representing which network element types the condition, category, or function barriers apply to (default is junctionsAndEdges).
    */
    'traversabilityScope'?: TraceConfiguration.TraversabilityScopeEnum;
    /**
    * Optional parameter containing an array of objects (representing network attribute conditions) that serve as barriers - default is null. If isTypeSpecificValue is true, the network attribute is being compared with a specific value ; otherwise the network attribute is being compared with another network attribute.
    */
    'conditionBarriers': Array<ConditionBarrier>;
    /**
    * The categories that serve as barriers (default is none) : optional parameter.
    */
    'categoryBarriers'?: Array<string>;
    /**
    * optional parameter.
    */
    'functionBarriers': Array<FunctionBarrier>;
    'arcadeExpressionBarrier'?: string;
    /**
    * A second pass is done over the trace results and all results after these categories are encountered are filtered (default is none) : optional parameter.
    */
    'filterBarriers': Array<string>;
    'filterFunctionBarriers': Array<string>;
    'filterScope'?: string;
    /**
    * Optional parameter ; an array of objects representing functions. Each function may have an optional array of network attribute conditions.
    */
    'functions': any;
    'nearestNeighbor': NearestNeighborParam;
    'outputFilters': Array<TraceOutputCondition>;
    /**
    * The categories associated with the output filter (default is none) ; optional parameter.
    */
    'outputConditions': Array<OutputFilter>;
    'propagators': Array<Propagator>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "includeContainers",
            "baseName": "includeContainers",
            "type": "boolean"
        },
        {
            "name": "includeContent",
            "baseName": "includeContent",
            "type": "boolean"
        },
        {
            "name": "includeStructures",
            "baseName": "includeStructures",
            "type": "boolean"
        },
        {
            "name": "includeBarriers",
            "baseName": "includeBarriers",
            "type": "boolean"
        },
        {
            "name": "validateConsistency",
            "baseName": "validateConsistency",
            "type": "boolean"
        },
        {
            "name": "domainNetworkName",
            "baseName": "domainNetworkName",
            "type": "string"
        },
        {
            "name": "tierName",
            "baseName": "tierName",
            "type": "string"
        },
        {
            "name": "targetTierName",
            "baseName": "targetTierName",
            "type": "string"
        },
        {
            "name": "subnetworkName",
            "baseName": "subnetworkName",
            "type": "string"
        },
        {
            "name": "diagramTemplateName",
            "baseName": "diagramTemplateName",
            "type": "string"
        },
        {
            "name": "shortestPathNetworkAttributeName",
            "baseName": "shortestPathNetworkAttributeName",
            "type": "string"
        },
        {
            "name": "filterBitsetNetworkAttributeName",
            "baseName": "filterBitsetNetworkAttributeName",
            "type": "string"
        },
        {
            "name": "traversabilityScope",
            "baseName": "traversabilityScope",
            "type": "TraceConfiguration.TraversabilityScopeEnum"
        },
        {
            "name": "conditionBarriers",
            "baseName": "conditionBarriers",
            "type": "Array<ConditionBarrier>"
        },
        {
            "name": "categoryBarriers",
            "baseName": "categoryBarriers",
            "type": "Array<string>"
        },
        {
            "name": "functionBarriers",
            "baseName": "functionBarriers",
            "type": "Array<FunctionBarrier>"
        },
        {
            "name": "arcadeExpressionBarrier",
            "baseName": "arcadeExpressionBarrier",
            "type": "string"
        },
        {
            "name": "filterBarriers",
            "baseName": "filterBarriers",
            "type": "Array<string>"
        },
        {
            "name": "filterFunctionBarriers",
            "baseName": "filterFunctionBarriers",
            "type": "Array<string>"
        },
        {
            "name": "filterScope",
            "baseName": "filterScope",
            "type": "string"
        },
        {
            "name": "functions",
            "baseName": "functions",
            "type": "any"
        },
        {
            "name": "nearestNeighbor",
            "baseName": "nearestNeighbor",
            "type": "NearestNeighborParam"
        },
        {
            "name": "outputFilters",
            "baseName": "outputFilters",
            "type": "Array<TraceOutputCondition>"
        },
        {
            "name": "outputConditions",
            "baseName": "outputConditions",
            "type": "Array<OutputFilter>"
        },
        {
            "name": "propagators",
            "baseName": "propagators",
            "type": "Array<Propagator>"
        }    ];

    static getAttributeTypeMap() {
        return TraceConfiguration.attributeTypeMap;
    }
}

export namespace TraceConfiguration {
    export enum TraversabilityScopeEnum {
        Junctions = <any> 'junctions',
        Edges = <any> 'edges',
        JunctionsAndEdges = <any> 'junctionsAndEdges'
    }
}
export class TraceLocation {
    'traceLocationType'?: TraceLocation.TraceLocationTypeEnum;
    'globalId'?: string;
    'percentAlong'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "traceLocationType",
            "baseName": "traceLocationType",
            "type": "TraceLocation.TraceLocationTypeEnum"
        },
        {
            "name": "globalId",
            "baseName": "globalId",
            "type": "string"
        },
        {
            "name": "percentAlong",
            "baseName": "percentAlong",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TraceLocation.attributeTypeMap;
    }
}

export namespace TraceLocation {
    export enum TraceLocationTypeEnum {
        StartingPoint = <any> 'startingPoint',
        StoppingPoint = <any> 'stoppingPoint'
    }
}
export class TraceLocations extends Array<TraceLocation> {

    static discriminator: string | undefined = undefined;

}

export class TraceOutputCondition {
    'name': string;
    'type': TraceOutputCondition.TypeEnum;
    'operator': string;
    'value'?: number;
    'combineUsingOr'?: boolean;
    'isSpecificValue': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "TraceOutputCondition.TypeEnum"
        },
        {
            "name": "operator",
            "baseName": "operator",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "number"
        },
        {
            "name": "combineUsingOr",
            "baseName": "combineUsingOr",
            "type": "boolean"
        },
        {
            "name": "isSpecificValue",
            "baseName": "isSpecificValue",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TraceOutputCondition.attributeTypeMap;
    }
}

export namespace TraceOutputCondition {
    export enum TypeEnum {
        NetworkAttribute = <any> 'networkAttribute',
        Category = <any> 'category'
    }
}
/**
* Model for TraceResults
*/
export class TraceResultsSet {
    'traceResults'?: TraceResultsSetTraceResults;
    'success'?: boolean;
    'error'?: TokenResponseError;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "traceResults",
            "baseName": "traceResults",
            "type": "TraceResultsSetTraceResults"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "TokenResponseError"
        }    ];

    static getAttributeTypeMap() {
        return TraceResultsSet.attributeTypeMap;
    }
}

export class TraceResultsSetTraceResults {
    'elements'?: Array<TraceResultsSetTraceResultsElements>;
    'diagramName'?: string;
    'globalFunctionResults'?: Array<string>;
    'kFeaturesForKNNFound'?: boolean;
    'startingPointsIgnored'?: boolean;
    'warnings'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "elements",
            "baseName": "elements",
            "type": "Array<TraceResultsSetTraceResultsElements>"
        },
        {
            "name": "diagramName",
            "baseName": "diagramName",
            "type": "string"
        },
        {
            "name": "globalFunctionResults",
            "baseName": "globalFunctionResults",
            "type": "Array<string>"
        },
        {
            "name": "kFeaturesForKNNFound",
            "baseName": "kFeaturesForKNNFound",
            "type": "boolean"
        },
        {
            "name": "startingPointsIgnored",
            "baseName": "startingPointsIgnored",
            "type": "boolean"
        },
        {
            "name": "warnings",
            "baseName": "warnings",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return TraceResultsSetTraceResults.attributeTypeMap;
    }
}

export class TraceResultsSetTraceResultsElements {
    'networkSourceId'?: number;
    'globalId'?: string;
    'objectId'?: number;
    'terminalId'?: number;
    'assetGroupCode'?: number;
    'assetTypeCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "networkSourceId",
            "baseName": "networkSourceId",
            "type": "number"
        },
        {
            "name": "globalId",
            "baseName": "globalId",
            "type": "string"
        },
        {
            "name": "objectId",
            "baseName": "objectId",
            "type": "number"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "number"
        },
        {
            "name": "assetGroupCode",
            "baseName": "assetGroupCode",
            "type": "number"
        },
        {
            "name": "assetTypeCode",
            "baseName": "assetTypeCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TraceResultsSetTraceResultsElements.attributeTypeMap;
    }
}

export class UpdateIsConnectedResponse {
    'moment'?: number;
    'success'?: string;
    'error'?: TokenResponseError;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "moment",
            "baseName": "moment",
            "type": "number"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "TokenResponseError"
        }    ];

    static getAttributeTypeMap() {
        return UpdateIsConnectedResponse.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "FunctionBarrier.FunctionTypeEnum": FunctionBarrier.FunctionTypeEnum,
        "FunctionBarrier.OperatorEnum": FunctionBarrier.OperatorEnum,
        "FunctionsInner.FunctionTypeEnum": FunctionsInner.FunctionTypeEnum,
        "FunctionsInnerNetworkAttributeConditions.OperatorEnum": FunctionsInnerNetworkAttributeConditions.OperatorEnum,
        "Propagator.FunctionTypeEnum": Propagator.FunctionTypeEnum,
        "Propagator.OperatorEnum": Propagator.OperatorEnum,
        "TraceConfiguration.TraversabilityScopeEnum": TraceConfiguration.TraversabilityScopeEnum,
        "TraceLocation.TraceLocationTypeEnum": TraceLocation.TraceLocationTypeEnum,
        "TraceOutputCondition.TypeEnum": TraceOutputCondition.TypeEnum,
}

let typeMap: {[index: string]: any} = {
    "ConditionBarrier": ConditionBarrier,
    "Feature": Feature,
    "FunctionBarrier": FunctionBarrier,
    "Functions": Functions,
    "FunctionsInner": FunctionsInner,
    "FunctionsInnerNetworkAttributeConditions": FunctionsInnerNetworkAttributeConditions,
    "NearestNeighborParam": NearestNeighborParam,
    "NetworkAttribute": NetworkAttribute,
    "OutputFilter": OutputFilter,
    "Propagator": Propagator,
    "TokenRequest": TokenRequest,
    "TokenResponse": TokenResponse,
    "TokenResponseError": TokenResponseError,
    "TraceConfiguration": TraceConfiguration,
    "TraceLocation": TraceLocation,
    "TraceLocations": TraceLocations,
    "TraceOutputCondition": TraceOutputCondition,
    "TraceResultsSet": TraceResultsSet,
    "TraceResultsSetTraceResults": TraceResultsSetTraceResults,
    "TraceResultsSetTraceResultsElements": TraceResultsSetTraceResultsElements,
    "UpdateIsConnectedResponse": UpdateIsConnectedResponse,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * UtilityNetworkService
     * @summary updateIsConnected
     * @param serverWebAdaptor 
     * @param utilityNetworkName 
     * @param f 
     * @param token 
     */
    public serverWebAdaptorRestServicesUtilityNetworkNameUtilityNetworkServerUpdateIsConnectedPost (serverWebAdaptor: string, utilityNetworkName: string, f: string, token: string) : Promise<{ response: http.ClientResponse; body: UpdateIsConnectedResponse;  }> {
        const localVarPath = this.basePath + '/{ServerWebAdaptor}/rest/services/{UtilityNetworkName}/UtilityNetworkServer/updateIsConnected'
            .replace('{' + 'ServerWebAdaptor' + '}', encodeURIComponent(String(serverWebAdaptor)))
            .replace('{' + 'UtilityNetworkName' + '}', encodeURIComponent(String(utilityNetworkName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serverWebAdaptor' is not null or undefined
        if (serverWebAdaptor === null || serverWebAdaptor === undefined) {
            throw new Error('Required parameter serverWebAdaptor was null or undefined when calling serverWebAdaptorRestServicesUtilityNetworkNameUtilityNetworkServerUpdateIsConnectedPost.');
        }

        // verify required parameter 'utilityNetworkName' is not null or undefined
        if (utilityNetworkName === null || utilityNetworkName === undefined) {
            throw new Error('Required parameter utilityNetworkName was null or undefined when calling serverWebAdaptorRestServicesUtilityNetworkNameUtilityNetworkServerUpdateIsConnectedPost.');
        }

        // verify required parameter 'f' is not null or undefined
        if (f === null || f === undefined) {
            throw new Error('Required parameter f was null or undefined when calling serverWebAdaptorRestServicesUtilityNetworkNameUtilityNetworkServerUpdateIsConnectedPost.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling serverWebAdaptorRestServicesUtilityNetworkNameUtilityNetworkServerUpdateIsConnectedPost.');
        }

        if (f !== undefined) {
            localVarQueryParameters['f'] = ObjectSerializer.serialize(f, "string");
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }


        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateIsConnectedResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateIsConnectedResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UtilityNetworkServiceApiApiKeys {
}

export class UtilityNetworkServiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UtilityNetworkServiceApiApiKeys, value: string) {
        (this.authentications as any)[UtilityNetworkServiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary generateToken
     * @param portalWebAdaptor 
     * @param username 
     * @param password 
     * @param expiration 
     * @param f 
     * @param ip 
     * @param referer 
     */
    public portalWebAdaptorSharingRestGenerateTokenPost (portalWebAdaptor: string, username: string, password: string, expiration: number, f: string, ip?: string, referer?: string) : Promise<{ response: http.ClientResponse; body: TokenResponse;  }> {
        const localVarPath = this.basePath + '/{PortalWebAdaptor}/sharing/rest/generateToken'
            .replace('{' + 'PortalWebAdaptor' + '}', encodeURIComponent(String(portalWebAdaptor)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'portalWebAdaptor' is not null or undefined
        if (portalWebAdaptor === null || portalWebAdaptor === undefined) {
            throw new Error('Required parameter portalWebAdaptor was null or undefined when calling portalWebAdaptorSharingRestGenerateTokenPost.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling portalWebAdaptorSharingRestGenerateTokenPost.');
        }

        // verify required parameter 'password' is not null or undefined
        if (password === null || password === undefined) {
            throw new Error('Required parameter password was null or undefined when calling portalWebAdaptorSharingRestGenerateTokenPost.');
        }

        // verify required parameter 'expiration' is not null or undefined
        if (expiration === null || expiration === undefined) {
            throw new Error('Required parameter expiration was null or undefined when calling portalWebAdaptorSharingRestGenerateTokenPost.');
        }

        // verify required parameter 'f' is not null or undefined
        if (f === null || f === undefined) {
            throw new Error('Required parameter f was null or undefined when calling portalWebAdaptorSharingRestGenerateTokenPost.');
        }


        let localVarUseFormData = false;

        if (username !== undefined) {
            localVarFormParams['username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            localVarFormParams['password'] = ObjectSerializer.serialize(password, "string");
        }

        if (ip !== undefined) {
            localVarFormParams['ip'] = ObjectSerializer.serialize(ip, "string");
        }

        if (referer !== undefined) {
            localVarFormParams['referer'] = ObjectSerializer.serialize(referer, "string");
        }

        if (expiration !== undefined) {
            localVarFormParams['expiration'] = ObjectSerializer.serialize(expiration, "number");
        }

        if (f !== undefined) {
            localVarFormParams['f'] = ObjectSerializer.serialize(f, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TokenResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TokenResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Trace
     * @summary trace
     * @param serverWebAdaptor 
     * @param utilityNetworkName 
     * @param token 
     * @param f Optional parameter representing the output format of the response (default is JSON).
     * @param traceType The trace type.
     * @param traceLocations ***Curently a workaround until figure out how to gen**The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.
     * @param traceConfiguration The locations for starting and stopping points, as well as barriers. Optional parameter for subnetwork trace type, required parameter for all other trace types.
     * @param gdbVersion The name of the geodatabase version.
     * @param sessionId Optional parameter representing the token (guid) used to lock the version. If the calling client has previously started a service session (editing) and holds an exclusive lock on the specified version, the request will fail if the sessionId is not provided. If the specified version is currently locked by any other session, the request will fail if the sessionId is not provided or does not match the sessionId which holds the exclusive lock.
     * @param moment Optional parameter representing the session moment (the default is the version current moment). This should only be specified by the client when they do not want to use the current moment.
     */
    public trace (serverWebAdaptor: string, utilityNetworkName: string, token: string, f: string, traceType: 'upstream' | 'downstream' | 'connected' | 'subnetwork' | 'unknown' | 'loops' | 'shortestpath' | 'subnetworkcontroller', traceLocations: string, traceConfiguration: string, gdbVersion?: string, sessionId?: string, moment?: string) : Promise<{ response: http.ClientResponse; body: TraceResultsSet;  }> {
        const localVarPath = this.basePath + '/{ServerWebAdaptor}/rest/services/{UtilityNetworkName}/UtilityNetworkServer/trace'
            .replace('{' + 'ServerWebAdaptor' + '}', encodeURIComponent(String(serverWebAdaptor)))
            .replace('{' + 'UtilityNetworkName' + '}', encodeURIComponent(String(utilityNetworkName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serverWebAdaptor' is not null or undefined
        if (serverWebAdaptor === null || serverWebAdaptor === undefined) {
            throw new Error('Required parameter serverWebAdaptor was null or undefined when calling trace.');
        }

        // verify required parameter 'utilityNetworkName' is not null or undefined
        if (utilityNetworkName === null || utilityNetworkName === undefined) {
            throw new Error('Required parameter utilityNetworkName was null or undefined when calling trace.');
        }

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling trace.');
        }

        // verify required parameter 'f' is not null or undefined
        if (f === null || f === undefined) {
            throw new Error('Required parameter f was null or undefined when calling trace.');
        }

        // verify required parameter 'traceType' is not null or undefined
        if (traceType === null || traceType === undefined) {
            throw new Error('Required parameter traceType was null or undefined when calling trace.');
        }

        // verify required parameter 'traceLocations' is not null or undefined
        if (traceLocations === null || traceLocations === undefined) {
            throw new Error('Required parameter traceLocations was null or undefined when calling trace.');
        }

        // verify required parameter 'traceConfiguration' is not null or undefined
        if (traceConfiguration === null || traceConfiguration === undefined) {
            throw new Error('Required parameter traceConfiguration was null or undefined when calling trace.');
        }

        if (token !== undefined) {
            localVarQueryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }


        let localVarUseFormData = false;

        if (f !== undefined) {
            localVarFormParams['f'] = ObjectSerializer.serialize(f, "string");
        }

        if (gdbVersion !== undefined) {
            localVarFormParams['gdbVersion'] = ObjectSerializer.serialize(gdbVersion, "string");
        }

        if (sessionId !== undefined) {
            localVarFormParams['sessionId'] = ObjectSerializer.serialize(sessionId, "string");
        }

        if (moment !== undefined) {
            localVarFormParams['moment'] = ObjectSerializer.serialize(moment, "string");
        }

        if (traceType !== undefined) {
            localVarFormParams['traceType'] = ObjectSerializer.serialize(traceType, "'upstream' | 'downstream' | 'connected' | 'subnetwork' | 'unknown' | 'loops' | 'shortestpath' | 'subnetworkcontroller'");
        }

        if (traceLocations !== undefined) {
            localVarFormParams['traceLocations'] = ObjectSerializer.serialize(traceLocations, "string");
        }

        if (traceConfiguration !== undefined) {
            localVarFormParams['traceConfiguration'] = ObjectSerializer.serialize(traceConfiguration, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TraceResultsSet;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TraceResultsSet");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
